<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
<!-- 2024-11-22 vie 14:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Apuntes Sistemas Operativos</title>
<meta name="author" content="likcos" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
<style> #content{max-width:1800px;}</style>
<style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Apuntes Sistemas Operativos</h1>
<div id="table-of-contents" role="doc-toc">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgef9c998">Administración de Procesos y del procesador</a>
<ul>
<li><a href="#org48bff98">Comandos para manejar procesos en Linux</a>
<ul>
<li><a href="#orgd5ea803">1. Ver procesos activos</a></li>
<li><a href="#org8498559">2. Iniciar procesos</a></li>
<li><a href="#org1b1b251">3. Controlar la ejecución de procesos</a></li>
<li><a href="#org8b21525">4. Enviar señales a los procesos</a></li>
<li><a href="#orgddb1306">5. Cambiar prioridad de procesos</a></li>
<li><a href="#org78f19fb">6. Ver detalles específicos de los procesos</a></li>
</ul>
</li>
<li><a href="#org8929c6f">Punteros en C</a>
<ul>
<li><a href="#orgae54ea1">¿Qué es un puntero?</a></li>
<li><a href="#orgdeb6f83">Declaración de punteros</a></li>
<li><a href="#orgd1a0ee1">Inicialización de punteros</a></li>
<li><a href="#org2f3ba55">Acceso al valor apuntado</a></li>
<li><a href="#orga93df07">Punteros y arreglos</a></li>
<li><a href="#org23e147b">Punteros y funciones</a></li>
<li><a href="#org39213e0">Punteros nulos</a></li>
<li><a href="#org590fc1a">Aritmética de punteros</a></li>
<li><a href="#org00a5331">Punteros a punteros</a></li>
<li><a href="#org8f75129">Dobles y triples punteros</a></li>
<li><a href="#org9346e50">Punteros y cadenas de caracteres</a></li>
</ul>
</li>
<li><a href="#orgab3c0c3">Concepto de proceso</a></li>
<li><a href="#org7d913fa">Fork() en C</a>
<ul>
<li><a href="#orgf888737">¿Qué es fork()?</a></li>
<li><a href="#org0a5b451">Funcionamiento básico de fork()</a></li>
<li><a href="#org18cee42">Ejemplo básico de fork()</a></li>
<li><a href="#org7b72928">Explicación del Ejemplo</a></li>
<li><a href="#org47503a2">Espera del Proceso Padre con wait()</a></li>
<li><a href="#orge4a7630">fork() y Punteros</a></li>
<li><a href="#orgf85fbdd">Ejemplo con Punteros</a></li>
<li><a href="#org29d99a6">Salida esperada</a></li>
<li><a href="#org99241d6">Explicación de Copy-on-Write (COW)</a></li>
<li><a href="#org7e53186">Conclusión</a></li>
</ul>
</li>
<li><a href="#org7aee2e0">Estados y transiciones de los procesos</a>
<ul>
<li><a href="#org7d13ac6">Ejemplo en C: Creación de un proceso utilizando fork()</a></li>
<li><a href="#org8f4ca52">Ejemplo en C: Simulación de transiciones de estados</a></li>
</ul>
</li>
<li><a href="#orgd6a3851">Tabla de Procesos</a>
<ul>
<li><a href="#orgff053a6">¿Qué es la Tabla de Procesos?</a></li>
<li><a href="#orgd14d00a">Información en la Tabla de Procesos</a></li>
<li><a href="#org1352ecc">Estados del Proceso</a></li>
<li><a href="#org589ed98">Ejemplo en C de una Tabla de Procesos Simplificada</a></li>
<li><a href="#org6775387">Explicación del Ejemplo</a></li>
<li><a href="#org0422949">Salida Esperada</a></li>
<li><a href="#org25d5767">Conclusión</a></li>
</ul>
</li>
<li><a href="#org4c88503">Procesos ligeros: Hilos o hebras</a>
<ul>
<li><a href="#org27418d0">Ejemplo en C: Creación de hilos con pthread</a></li>
</ul>
</li>
<li><a href="#org17c0dff">pthread<sub>create</sub> en C</a>
<ul>
<li><a href="#org2034196">Descripción de pthread<sub>create</sub></a></li>
<li><a href="#org00c8f60">Sintaxis de pthread<sub>create</sub></a></li>
<li><a href="#org5d6eb9f">Parámetros</a></li>
<li><a href="#org8de324d">Valor de Retorno</a></li>
<li><a href="#org59175ba">Ejemplo Práctico de pthread<sub>create</sub></a></li>
<li><a href="#org23f6851">Explicación del Ejemplo</a></li>
<li><a href="#org2804ee0">Consideraciones Importantes</a></li>
<li><a href="#org235635c">Resumen</a></li>
</ul>
</li>
<li><a href="#org126082f">cola con prioridad</a></li>
<li><a href="#orgc94a636">Concurrencia y Secuenciabilidad</a>
<ul>
<li><a href="#org50cfdcf">Ejemplo en C: Concurrencia y sincronización de tareas</a></li>
<li><a href="#org3cd23ea">1.1 Exclusión Mutua</a></li>
<li><a href="#orgec23cd6">1.2 Sincronización</a></li>
<li><a href="#org8a7fb58">1.3 Condiciones de carrera y sincronización</a></li>
</ul>
</li>
<li><a href="#org1ce979d">Secuenciabilidad</a>
<ul>
<li><a href="#org0b9425d">2.1 Algoritmos de Planificación de Procesos</a></li>
<li><a href="#org6515556">2.2 Algoritmos de Detección y Prevención de Interbloqueos (Deadlocks)</a></li>
<li><a href="#org66040bb">2.3 Sincronización y Secuenciabilidad</a></li>
<li><a href="#org340262c">3. Conclusión</a></li>
</ul>
</li>
<li><a href="#org85d4b8c">Niveles, Objetivos y Criterios de Planificación</a>
<ul>
<li><a href="#org8800a6e">Niveles de Planificación</a></li>
<li><a href="#orge0c1309">Objetivos de la Planificación</a></li>
<li><a href="#orga12c0dd">Criterios de Planificación</a></li>
<li><a href="#org46d0fb1">Ejemplo en C: Implementación Simple de Planificación Round Robin</a></li>
</ul>
</li>
<li><a href="#orgfeb9f94">Técnicas de Administración del Planificador</a></li>
</ul>
</li>
<li><a href="#org32366b7">Administración de la memoria</a>
<ul>
<li><a href="#org4e4fecd">Política y filosofía de la administración de memoria</a>
<ul>
<li><a href="#org096bb91">Ejemplos de administración de memoria</a></li>
<li><a href="#orgd75a3cb">Swapping</a></li>
<li><a href="#orgb85b50d">Fragmentación</a></li>
<li><a href="#orgb8eefee">Prioridades</a></li>
</ul>
</li>
<li><a href="#orgc7c86a2">Memoria real</a></li>
<li><a href="#org816e73e">Organización de memoria virtual</a></li>
<li><a href="#org0a40e34">Administración de memoria virtual</a>
<ul>
<li><a href="#org4f3be3a">Estrategias de Asignación</a></li>
<li><a href="#org338d1d2">Componentes Principales</a></li>
<li><a href="#org79538d8">Ejemplo: Proceso de Fallo de Página</a></li>
</ul>
</li>
<li><a href="#orgb0ce7a4">Ejercicios</a>
<ul>
<li><a href="#org1e9aa75">Respuestas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org573b4f0">Problema de los Filósofos</a></li>
</ul>
</div>
</div>



<div id="outline-container-orgef9c998" class="outline-2">
<h2 id="orgef9c998">Administración de Procesos y del procesador</h2>
<div class="outline-text-2" id="text-orgef9c998">
</div>
<div id="outline-container-org48bff98" class="outline-3">
<h3 id="org48bff98">Comandos para manejar procesos en Linux</h3>
<div class="outline-text-3" id="text-org48bff98">
</div>
<div id="outline-container-orgd5ea803" class="outline-4">
<h4 id="orgd5ea803">1. Ver procesos activos</h4>
<div class="outline-text-4" id="text-orgd5ea803">
<ul class="org-ul">
<li>`ps`
Muestra una lista de procesos en la terminal actual. Ofrece información sobre el PID, usuario, CPU, memoria, etc.
<ul class="org-ul">
<li>Ejemplo: `ps aux` muestra todos los procesos en ejecución en el sistema.</li>
</ul></li>

<li>`top` 
Muestra una lista dinámica de procesos en tiempo real, actualizándose constantemente. Incluye el uso de CPU, memoria, y estadísticas del sistema.
<ul class="org-ul">
<li>Comando alternativo: `htop`, que ofrece una interfaz más visual y personalizable.</li>
</ul></li>

<li>`pgrep &lt;nombre&gt;`
Busca el PID (Process ID) de un proceso específico por su nombre. Útil para obtener el PID antes de aplicar otros comandos.
<ul class="org-ul">
<li>Ejemplo: `pgrep apache` muestra el PID del proceso con el nombre "apache".</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org8498559" class="outline-4">
<h4 id="org8498559">2. Iniciar procesos</h4>
<div class="outline-text-4" id="text-org8498559">
<ul class="org-ul">
<li>`&amp;` 
Ejecuta un comando en segundo plano, permitiendo que el usuario continúe usando la terminal. 
<ul class="org-ul">
<li>Ejemplo: `comando &amp;` ejecuta el proceso en segundo plano.</li>
</ul></li>

<li>`nohup &lt;comando&gt; &amp;`
Inicia un proceso que continúa en ejecución incluso después de cerrar la terminal. El output se guarda en un archivo `nohup.out` por defecto.
<ul class="org-ul">
<li>Ejemplo: `nohup script.sh &amp;` ejecuta `script.sh` y permanece activo tras cerrar sesión.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org1b1b251" class="outline-4">
<h4 id="org1b1b251">3. Controlar la ejecución de procesos</h4>
<div class="outline-text-4" id="text-org1b1b251">
<ul class="org-ul">
<li>`fg` 
Trae un proceso en segundo plano al primer plano, permitiendo interactuar directamente con él.</li>

<li>`bg`
Envía un proceso suspendido al segundo plano, liberando la terminal para otros comandos.</li>

<li>`jobs`
Muestra los procesos en segundo plano o suspendidos asociados a la sesión de terminal actual, con su ID de trabajo (job ID).</li>
</ul>
</div>
</div>

<div id="outline-container-org8b21525" class="outline-4">
<h4 id="org8b21525">4. Enviar señales a los procesos</h4>
<div class="outline-text-4" id="text-org8b21525">
<ul class="org-ul">
<li>`kill &lt;PID&gt;` 
Envía una señal de terminación al proceso especificado por su PID. Intenta cerrar el proceso de manera controlada.
<ul class="org-ul">
<li>Ejemplo: `kill 1234` termina el proceso con PID 1234.</li>
</ul></li>

<li>`kill -9 &lt;PID&gt;`
Fuerza el cierre inmediato del proceso especificado, sin esperar una terminación ordenada. Utiliza la señal `KILL`.
<ul class="org-ul">
<li>Ejemplo: `kill -9 1234`.</li>
</ul></li>

<li>`pkill &lt;nombre&gt;`
Termina todos los procesos que coinciden con el nombre especificado.
<ul class="org-ul">
<li>Ejemplo: `pkill apache` detiene todos los procesos con nombre "apache".</li>
</ul></li>

<li>`killall &lt;nombre&gt;`
Similar a `pkill`, detiene todos los procesos con un nombre específico.
<ul class="org-ul">
<li>Ejemplo: `killall httpd`.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgddb1306" class="outline-4">
<h4 id="orgddb1306">5. Cambiar prioridad de procesos</h4>
<div class="outline-text-4" id="text-orgddb1306">
<ul class="org-ul">
<li>`nice -n &lt;prioridad&gt; &lt;comando&gt;`
Inicia un proceso con una prioridad especificada, donde el rango va de -20 (mayor prioridad) a 19 (menor prioridad). La prioridad afecta el orden de planificación.
<ul class="org-ul">
<li>Ejemplo: `nice -n -10 script.sh` ejecuta `script.sh` con una prioridad alta.</li>
</ul></li>

<li>`renice &lt;prioridad&gt; &lt;PID&gt;`
Cambia la prioridad de un proceso en ejecución.
<ul class="org-ul">
<li>Ejemplo: `renice -5 1234` ajusta la prioridad del proceso con PID 1234.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org78f19fb" class="outline-4">
<h4 id="org78f19fb">6. Ver detalles específicos de los procesos</h4>
<div class="outline-text-4" id="text-org78f19fb">
<ul class="org-ul">
<li>`pstree`
Muestra los procesos en una estructura de árbol, permitiendo visualizar mejor las relaciones y jerarquías entre procesos en ejecución.</li>

<li>`lsof -p &lt;PID&gt;`
Lista todos los archivos abiertos por un proceso específico, útil para ver conexiones de red o archivos utilizados por un proceso.
<ul class="org-ul">
<li>Ejemplo: `lsof -p 1234` muestra los archivos abiertos por el proceso con PID 1234.</li>
</ul></li>
</ul>
</div>
</div>
</div>



<div id="outline-container-org8929c6f" class="outline-3">
<h3 id="org8929c6f">Punteros en C</h3>
<div class="outline-text-3" id="text-org8929c6f">
</div>
<div id="outline-container-orgae54ea1" class="outline-4">
<h4 id="orgae54ea1">¿Qué es un puntero?</h4>
<div class="outline-text-4" id="text-orgae54ea1">
<p>
Un puntero es una variable que almacena la dirección de memoria de
otra variable. En lugar de contener un valor directo, un puntero
"apunta" a la ubicación donde se almacena ese valor.
</p>
</div>
</div>

<div id="outline-container-orgdeb6f83" class="outline-4">
<h4 id="orgdeb6f83">Declaración de punteros</h4>
<div class="outline-text-4" id="text-orgdeb6f83">
<p>
Para declarar un puntero, se utiliza el operador `*` antes del nombre
de la variable:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> *<span style="color: #a0522d;">ptr</span>;
</pre>
</div>

<p>
En este ejemplo, `ptr` es un puntero a un entero.
</p>
</div>
</div>

<div id="outline-container-orgd1a0ee1" class="outline-4">
<h4 id="orgd1a0ee1">Inicialización de punteros</h4>
<div class="outline-text-4" id="text-orgd1a0ee1">
<p>
Un puntero debe inicializarse con la dirección de una variable antes de ser utilizado. Para obtener la dirección de una variable, se emplea el operador `&amp;`:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">var</span> = 10;
<span style="color: #228b22;">int</span> *<span style="color: #a0522d;">ptr</span> = &amp;var;
</pre>
</div>

<p>
Aquí, `ptr` almacena la dirección de `var`.
</p>
</div>
</div>

<div id="outline-container-org2f3ba55" class="outline-4">
<h4 id="org2f3ba55">Acceso al valor apuntado</h4>
<div class="outline-text-4" id="text-org2f3ba55">
<p>
Para acceder o modificar el valor de la variable a la que apunta un
puntero, se utiliza el operador de desreferencia `*`:
</p>

<div class="org-src-container">
<pre class="src src-c">printf<span style="color: #707183;">(</span><span style="color: #8b2252;">"Valor de var: %d\n"</span>, *ptr<span style="color: #707183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Imprime: Valor de var: 10</span>
*ptr = 20; <span style="color: #b22222;">// </span><span style="color: #b22222;">Ahora var vale 20</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga93df07" class="outline-4">
<h4 id="orga93df07">Punteros y arreglos</h4>
<div class="outline-text-4" id="text-orga93df07">
<p>
En C, el nombre de un arreglo actúa como un puntero al primer elemento
del mismo. Por lo tanto, se puede utilizar aritmética de punteros para
recorrer un arreglo:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">arr</span><span style="color: #707183;">[</span>3<span style="color: #707183;">]</span> = <span style="color: #707183;">{</span>1, 2, 3<span style="color: #707183;">}</span>;
<span style="color: #228b22;">int</span> *<span style="color: #a0522d;">ptr</span> = arr;

<span style="color: #a020f0;">for</span> <span style="color: #707183;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; 3; i++<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"%d "</span>, *<span style="color: #909183;">(</span>ptr + i<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">Salida: 1 2 3</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org23e147b" class="outline-4">
<h4 id="org23e147b">Punteros y funciones</h4>
<div class="outline-text-4" id="text-org23e147b">
<p>
Los punteros permiten que las funciones modifiquen variables fuera de
su ámbito local. Al pasar la dirección de una variable a una función,
esta puede alterar el valor original:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">incrementar</span><span style="color: #707183;">(</span><span style="color: #228b22;">int</span> *<span style="color: #a0522d;">n</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #7388d6;">(</span>*n<span style="color: #7388d6;">)</span>++;
<span style="color: #707183;">}</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">num</span> = 5;
    incrementar<span style="color: #7388d6;">(</span>&amp;num<span style="color: #7388d6;">)</span>;
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Valor de num: %d\n"</span>, num<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Imprime: Valor de num: 6</span>
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org39213e0" class="outline-4">
<h4 id="org39213e0">Punteros nulos</h4>
<div class="outline-text-4" id="text-org39213e0">
<p>
Un puntero nulo es un puntero que no apunta a ninguna dirección
válida. Se inicializa asignándole el valor `NULL`:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> *<span style="color: #a0522d;">ptr</span> = <span style="color: #008b8b;">NULL</span>;
</pre>
</div>

<p>
Es una buena práctica inicializar los punteros a `NULL` para evitar
errores al intentar acceder a direcciones de memoria no válidas.
</p>
</div>
</div>

<div id="outline-container-org590fc1a" class="outline-4">
<h4 id="org590fc1a">Aritmética de punteros</h4>
<div class="outline-text-4" id="text-org590fc1a">
<p>
Los punteros pueden incrementarse o decrementarse para navegar por
estructuras de datos en memoria:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">arr</span><span style="color: #707183;">[</span>3<span style="color: #707183;">]</span> = <span style="color: #707183;">{</span>10, 20, 30<span style="color: #707183;">}</span>;
<span style="color: #228b22;">int</span> *<span style="color: #a0522d;">ptr</span> = arr;

ptr++; <span style="color: #b22222;">// </span><span style="color: #b22222;">Ahora apunta a arr[1]</span>
printf<span style="color: #707183;">(</span><span style="color: #8b2252;">"%d\n"</span>, *ptr<span style="color: #707183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Imprime: 20</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org00a5331" class="outline-4">
<h4 id="org00a5331">Punteros a punteros</h4>
<div class="outline-text-4" id="text-org00a5331">
<p>
Un puntero puede apuntar a otro puntero, lo que se denomina "puntero a puntero":
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">var</span> = 100;
<span style="color: #228b22;">int</span> *<span style="color: #a0522d;">ptr</span> = &amp;var;
<span style="color: #228b22;">int</span> **<span style="color: #a0522d;">ptr2</span> = &amp;ptr;

printf<span style="color: #707183;">(</span><span style="color: #8b2252;">"Valor de var: %d\n"</span>, **ptr2<span style="color: #707183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Imprime: Valor de var: 100</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f75129" class="outline-4">
<h4 id="org8f75129">Dobles y triples punteros</h4>
<div class="outline-text-4" id="text-org8f75129">
<p>
Un <b><b>doble puntero</b></b> es un puntero que apunta a otro puntero,
permitiendo manejar niveles adicionales de indirección en la
memoria. Estos son útiles en casos como el manejo de matrices
dinámicas o la manipulación de punteros en funciones.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">var</span> = 50;
<span style="color: #228b22;">int</span> *<span style="color: #a0522d;">ptr</span> = &amp;var;
<span style="color: #228b22;">int</span> **<span style="color: #a0522d;">dbl_ptr</span> = &amp;ptr;

printf<span style="color: #707183;">(</span><span style="color: #8b2252;">"Valor de var usando dbl_ptr: %d\n"</span>, **dbl_ptr<span style="color: #707183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Imprime: 50</span>
</pre>
</div>

<p>
Los <b><b>triples punteros</b></b> (punteros a dobles punteros) permiten gestionar
estructuras de datos de mayor complejidad, como matrices 3D o
estructuras donde necesitas referencias a varios niveles de punteros.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">var</span> = 30;
<span style="color: #228b22;">int</span> *<span style="color: #a0522d;">ptr</span> = &amp;var;
<span style="color: #228b22;">int</span> **<span style="color: #a0522d;">dbl_ptr</span> = &amp;ptr;
<span style="color: #228b22;">int</span> ***<span style="color: #a0522d;">trp_ptr</span> = &amp;dbl_ptr;

printf<span style="color: #707183;">(</span><span style="color: #8b2252;">"Valor de var usando trp_ptr: %d\n"</span>, ***trp_ptr<span style="color: #707183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Imprime: 30</span>
</pre>
</div>

<p>
Usar punteros de múltiples niveles requiere tener una buena comprensión de cómo funciona la memoria en C y saber manejar las referencias con cuidado para evitar errores de acceso a memoria.
</p>
</div>
</div>


<div id="outline-container-org9346e50" class="outline-4">
<h4 id="org9346e50">Punteros y cadenas de caracteres</h4>
<div class="outline-text-4" id="text-org9346e50">
<p>
Las cadenas de caracteres en C son arreglos de caracteres terminados en un carácter nulo (`'\0'`). Los punteros se utilizan comúnmente para manipular estas cadenas:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">char</span> <span style="color: #a0522d;">str</span><span style="color: #707183;">[]</span> = <span style="color: #8b2252;">"Hola"</span>;
<span style="color: #228b22;">char</span> *<span style="color: #a0522d;">ptr</span> = str;

<span style="color: #a020f0;">while</span> <span style="color: #707183;">(</span>*ptr != <span style="color: #8b2252;">'\0'</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"%c"</span>, *ptr<span style="color: #7388d6;">)</span>;
    ptr++;
<span style="color: #707183;">}</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">Salida: Hola</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgab3c0c3" class="outline-3">
<h3 id="orgab3c0c3">Concepto de proceso</h3>
<div class="outline-text-3" id="text-orgab3c0c3">
<p>
Un proceso es una unidad de ejecución dentro de un sistema
operativo. Cada proceso tiene su propio espacio de memoria, que
incluye el código del programa, sus datos y su pila. La creación de un
proceso implica varias operaciones del sistema operativo, como
asignación de memoria y registro en la tabla de procesos. Los procesos
permiten a los sistemas multitarea ejecutar múltiples programas de
forma aparentemente simultánea.
</p>
</div>
</div>

<div id="outline-container-org7d913fa" class="outline-3">
<h3 id="org7d913fa">Fork() en C</h3>
<div class="outline-text-3" id="text-org7d913fa">
</div>
<div id="outline-container-orgf888737" class="outline-4">
<h4 id="orgf888737">¿Qué es fork()?</h4>
<div class="outline-text-4" id="text-orgf888737">
<p>
`fork()` es una llamada al sistema en C, utilizada para crear un nuevo
proceso llamado "proceso hijo". Este proceso es una copia casi exacta
del proceso que hizo la llamada, conocido como "proceso padre". La
función `fork()` es esencial para el manejo de procesos en sistemas
tipo Unix/Linux.
</p>
</div>
</div>

<div id="outline-container-org0a5b451" class="outline-4">
<h4 id="org0a5b451">Funcionamiento básico de fork()</h4>
<div class="outline-text-4" id="text-org0a5b451">
<p>
Cuando se llama a `fork()`, la ejecución continúa tanto en el proceso
padre como en el proceso hijo. La llamada a `fork()` retorna un valor
distinto en cada uno:
</p>
<ul class="org-ul">
<li>Al proceso <b><b>padre</b></b>, `fork()` devuelve el PID (identificador de
proceso) del proceso hijo.</li>
<li>Al proceso <b><b>hijo</b></b>, `fork()` devuelve el valor `0`.</li>
<li>Si ocurre un error, `fork()` retorna `-1`.</li>
</ul>
</div>
</div>

<div id="outline-container-org18cee42" class="outline-4">
<h4 id="org18cee42">Ejemplo básico de fork()</h4>
<div class="outline-text-4" id="text-org18cee42">
<p>
A continuación, un ejemplo sencillo que muestra cómo usar `fork()`
para crear un proceso hijo:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">unistd.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">pid_t</span> <span style="color: #a0522d;">pid</span> = fork<span style="color: #7388d6;">()</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Llamada a fork()</span>

    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>pid == -1<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        <span style="color: #b22222;">// </span><span style="color: #b22222;">Si ocurre un error en fork()</span>
        perror<span style="color: #909183;">(</span><span style="color: #8b2252;">"fork failed"</span><span style="color: #909183;">)</span>;
        <span style="color: #a020f0;">return</span> 1;
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>pid == 0<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        <span style="color: #b22222;">// </span><span style="color: #b22222;">C&#243;digo que ejecuta el proceso hijo</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Este es el proceso hijo con PID: %d\n"</span>, getpid<span style="color: #709870;">()</span><span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
        <span style="color: #b22222;">// </span><span style="color: #b22222;">C&#243;digo que ejecuta el proceso padre</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Este es el proceso padre con PID: %d y el hijo tiene PID: %d\n"</span>, getpid<span style="color: #709870;">()</span>, pid<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7b72928" class="outline-4">
<h4 id="org7b72928">Explicación del Ejemplo</h4>
<div class="outline-text-4" id="text-org7b72928">
<ol class="org-ol">
<li>`fork()` es llamado y crea un proceso hijo.</li>
<li>En el proceso hijo, `pid` será igual a `0`, por lo que se ejecutará
el bloque de código que imprime el mensaje del hijo.</li>
<li>En el proceso padre, `pid` es mayor que `0`, por lo que ejecuta el
código para el proceso padre.</li>
<li>Si `fork()` falla, devuelve `-1` y se imprime un mensaje de error.</li>
</ol>
</div>
</div>

<div id="outline-container-org47503a2" class="outline-4">
<h4 id="org47503a2">Espera del Proceso Padre con wait()</h4>
<div class="outline-text-4" id="text-org47503a2">
<p>
Para que el proceso padre espere a que el proceso hijo termine antes
de continuar, se puede utilizar la función `wait()`:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">unistd.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #b22222;">//</span><span style="color: #b22222;">#include &lt;sys/wait.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">pid_t</span> <span style="color: #a0522d;">pid</span> = fork<span style="color: #7388d6;">()</span>;

    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>pid == 0<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        <span style="color: #b22222;">// </span><span style="color: #b22222;">Proceso hijo</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Proceso hijo con PID: %d\n"</span>, getpid<span style="color: #709870;">()</span><span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
        <span style="color: #b22222;">// </span><span style="color: #b22222;">Proceso padre</span>
<span style="color: #b22222;">//        </span><span style="color: #b22222;">wait(NULL); // Espera a que el proceso hijo termine</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Proceso padre con PID: %d, el hijo termin&#243;.\n"</span>, getpid<span style="color: #709870;">()</span><span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
En este ejemplo, el proceso padre esperará hasta que el proceso hijo
termine antes de imprimir su mensaje.
</p>
</div>
</div>

<div id="outline-container-orge4a7630" class="outline-4">
<h4 id="orge4a7630">fork() y Punteros</h4>
<div class="outline-text-4" id="text-orge4a7630">
<p>
`fork()` crea un espacio de memoria independiente para el proceso
hijo, lo que significa que los punteros en el proceso hijo apuntan a
las mismas posiciones relativas que en el proceso padre, pero en
diferentes espacios de memoria. Esto evita que los cambios en las
variables del proceso hijo afecten al padre, gracias al mecanismo de
<b><b>Copy-on-Write (COW)</b></b>.
</p>
</div>
</div>

<div id="outline-container-orgf85fbdd" class="outline-4">
<h4 id="orgf85fbdd">Ejemplo con Punteros</h4>
<div class="outline-text-4" id="text-orgf85fbdd">
<p>
Este ejemplo demuestra cómo `fork()` maneja los punteros y el espacio de memoria independiente:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">unistd.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdlib.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> *<span style="color: #a0522d;">ptr</span> = <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>*<span style="color: #7388d6;">)</span>malloc<span style="color: #7388d6;">(</span><span style="color: #a020f0;">sizeof</span><span style="color: #909183;">(</span><span style="color: #228b22;">int</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    *ptr = 100;

    <span style="color: #228b22;">pid_t</span> <span style="color: #a0522d;">pid</span> = fork<span style="color: #7388d6;">()</span>;

    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>pid == 0<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        <span style="color: #b22222;">// </span><span style="color: #b22222;">Proceso hijo</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Proceso hijo: valor de *ptr antes de cambiar = %d\n"</span>, *ptr<span style="color: #909183;">)</span>;
        *ptr = 200;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Proceso hijo: valor de *ptr despu&#233;s de cambiar = %d\n"</span>, *ptr<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
        <span style="color: #b22222;">// </span><span style="color: #b22222;">Proceso padre</span>
        wait<span style="color: #909183;">(</span><span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Proceso padre: valor de *ptr = %d\n"</span>, *ptr<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>

    free<span style="color: #7388d6;">(</span>ptr<span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org29d99a6" class="outline-4">
<h4 id="org29d99a6">Salida esperada</h4>
<div class="outline-text-4" id="text-org29d99a6">
<p>
La salida de este código será algo similar a:
</p>

<pre class="example">
Proceso hijo: valor de *ptr antes de cambiar = 100
Proceso hijo: valor de *ptr después de cambiar = 200
Proceso padre: valor de *ptr = 100
</pre>
</div>
</div>

<div id="outline-container-org99241d6" class="outline-4">
<h4 id="org99241d6">Explicación de Copy-on-Write (COW)</h4>
<div class="outline-text-4" id="text-org99241d6">
<p>
Gracias a Copy-on-Write, ambos procesos (padre e hijo) comparten la misma memoria hasta que uno de ellos intenta modificarla. En ese momento, el sistema operativo crea una copia independiente de la memoria para el proceso que realiza la escritura, evitando que los cambios afecten al otro proceso.
</p>
</div>
</div>

<div id="outline-container-org7e53186" class="outline-4">
<h4 id="org7e53186">Conclusión</h4>
<div class="outline-text-4" id="text-org7e53186">
<p>
La llamada a `fork()` es una herramienta poderosa en C para la creación de procesos en sistemas operativos Unix/Linux. Permite duplicar un proceso, crear nuevos flujos de ejecución, y manejar recursos compartidos de manera controlada. Es especialmente útil en programas multitarea como servidores o aplicaciones que requieren procesamiento paralelo.
</p>
</div>
</div>
</div>

<div id="outline-container-org7aee2e0" class="outline-3">
<h3 id="org7aee2e0">Estados y transiciones de los procesos</h3>
<div class="outline-text-3" id="text-org7aee2e0">
<p>
Los procesos en un sistema operativo pueden estar en diferentes
estados, que determinan si están utilizando la CPU, esperando, o
listos para ejecutarse. Los estados comunes incluyen:
</p>
<ul class="org-ul">
<li><b><b>Nuevo</b></b>: El proceso está siendo creado.</li>
<li><b><b>Listo</b></b>: El proceso está listo para ejecutarse.</li>
<li><b><b>Ejecución</b></b>: El proceso está ejecutándose en la CPU.</li>
<li><b><b>Bloqueado</b></b>: El proceso está esperando un evento externo (por ejemplo, entrada/salida).</li>
<li><b><b>Terminado</b></b>: El proceso ha completado su ejecución.</li>
</ul>

<p>
Los sistemas operativos gestionan estas transiciones mediante una
estructura de datos llamada tabla de procesos.
</p>
</div>


<div id="outline-container-org7d13ac6" class="outline-4">
<h4 id="org7d13ac6">Ejemplo en C: Creación de un proceso utilizando fork()</h4>
<div class="outline-text-4" id="text-org7d13ac6">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">unistd.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">sys/types.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">pid_t</span> <span style="color: #a0522d;">pid</span> = fork<span style="color: #7388d6;">()</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Crear un nuevo proceso</span>
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>pid == 0<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Soy el proceso hijo con PID %d\n"</span>, getpid<span style="color: #709870;">()</span><span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Soy el proceso padre con PID %d\n"</span>, getpid<span style="color: #709870;">()</span><span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-org8f4ca52" class="outline-4">
<h4 id="org8f4ca52">Ejemplo en C: Simulación de transiciones de estados</h4>
<div class="outline-text-4" id="text-org8f4ca52">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">unistd.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdlib.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">sys/wait.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Proceso creado\n"</span><span style="color: #7388d6;">)</span>;
    <span style="color: #228b22;">pid_t</span> <span style="color: #a0522d;">pid</span> = fork<span style="color: #7388d6;">()</span>;
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>pid == 0<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Estado: Ejecuci&#243;n - Proceso hijo\n"</span><span style="color: #909183;">)</span>;
        sleep<span style="color: #909183;">(</span>2<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Simula un proceso en espera (bloqueado)</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Estado: Terminado - Proceso hijo\n"</span><span style="color: #909183;">)</span>;
        exit<span style="color: #909183;">(</span>0<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Estado: Listo - Proceso padre\n"</span><span style="color: #909183;">)</span>;
        wait<span style="color: #909183;">(</span><span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Espera a que el proceso hijo finalice</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Estado: Terminado - Proceso padre\n"</span><span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd6a3851" class="outline-3">
<h3 id="orgd6a3851">Tabla de Procesos</h3>
<div class="outline-text-3" id="text-orgd6a3851">
</div>
<div id="outline-container-orgff053a6" class="outline-4">
<h4 id="orgff053a6">¿Qué es la Tabla de Procesos?</h4>
<div class="outline-text-4" id="text-orgff053a6">
<p>
La <b><b>Tabla de Procesos</b></b> es una estructura de datos utilizada por el
sistema operativo para gestionar todos los procesos activos en el
sistema. Cada proceso tiene un bloque específico, llamado <b><b>Bloque de
Control de Proceso (PCB)</b></b>, que contiene la información necesaria para
su administración.
</p>
</div>
</div>

<div id="outline-container-orgd14d00a" class="outline-4">
<h4 id="orgd14d00a">Información en la Tabla de Procesos</h4>
<div class="outline-text-4" id="text-orgd14d00a">
<p>
Cada entrada en la tabla de procesos incluye un PCB con varios campos importantes:
</p>
<ul class="org-ul">
<li><b><b>PID (Process ID)</b></b>: Identificador único del proceso.</li>
<li><b><b>Estado del proceso</b></b>: Indica si el proceso está en ejecución, en
espera, listo, o terminado.</li>
<li><b><b>Contador de programa (PC)</b></b>: Dirección de la siguiente
instrucción que el proceso debe ejecutar.</li>
<li><b><b>Registros de la CPU</b></b>: Incluyen el estado de los registros del procesador.</li>
<li><b><b>Información de memoria</b></b>: Define las áreas de memoria asignadas al proceso.</li>
<li><b><b>Información de I/O</b></b>: Lista de archivos o dispositivos abiertos por el proceso.</li>
<li><b><b>Prioridad</b></b>: Define la importancia del proceso en relación a otros.</li>
</ul>
</div>
</div>

<div id="outline-container-org1352ecc" class="outline-4">
<h4 id="org1352ecc">Estados del Proceso</h4>
<div class="outline-text-4" id="text-org1352ecc">
<p>
Un proceso puede encontrarse en diferentes estados, y la tabla de procesos ayuda a rastrear el estado actual de cada proceso. Los estados típicos incluyen:
</p>
<ul class="org-ul">
<li><b><b>Nuevo</b></b>: El proceso está siendo creado.</li>
<li><b><b>Listo</b></b>: El proceso está esperando para ser ejecutado.</li>
<li><b><b>En ejecución</b></b>: El proceso está utilizando la CPU.</li>
<li><b><b>En espera/bloqueado</b></b>: El proceso espera un evento (como una operación de E/S).</li>
<li><b><b>Terminado</b></b>: El proceso ha finalizado su ejecución.</li>
</ul>
</div>
</div>

<div id="outline-container-org589ed98" class="outline-4">
<h4 id="org589ed98">Ejemplo en C de una Tabla de Procesos Simplificada</h4>
<div class="outline-text-4" id="text-org589ed98">
<p>
El siguiente ejemplo en C muestra cómo se puede representar una tabla
de procesos de manera simple mediante una estructura de datos.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">string.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MAX_PROCESSES</span> 5

<span style="color: #b22222;">// </span><span style="color: #b22222;">Definici&#243;n de estructura para la tabla de procesos</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Process</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">pid</span>;                 <span style="color: #b22222;">// </span><span style="color: #b22222;">ID del proceso</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">state</span><span style="color: #7388d6;">[</span>20<span style="color: #7388d6;">]</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">Estado del proceso (ej: "Listo", "Ejecutando")</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">priority</span>;            <span style="color: #b22222;">// </span><span style="color: #b22222;">Prioridad del proceso</span>
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">pc</span>;         <span style="color: #b22222;">// </span><span style="color: #b22222;">Contador de programa</span>
<span style="color: #707183;">}</span> <span style="color: #228b22;">Process</span>;

<span style="color: #b22222;">// </span><span style="color: #b22222;">Funci&#243;n para inicializar los procesos</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">initializeProcesses</span><span style="color: #707183;">(</span><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Process</span> <span style="color: #a0522d;">processes</span><span style="color: #7388d6;">[]</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">size</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; size; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        processes<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span>.pid = i + 1;
        strcpy<span style="color: #909183;">(</span>processes<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>.state, <span style="color: #8b2252;">"Listo"</span><span style="color: #909183;">)</span>;
        processes<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span>.priority = i % 3;  <span style="color: #b22222;">// </span><span style="color: #b22222;">Asigna prioridad de 0 a 2</span>
        processes<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span>.pc = 0;
    <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">Funci&#243;n para mostrar la tabla de procesos</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">displayProcessTable</span><span style="color: #707183;">(</span><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Process</span> <span style="color: #a0522d;">processes</span><span style="color: #7388d6;">[]</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">size</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Tabla de Procesos:\n"</span><span style="color: #7388d6;">)</span>;
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"PID\tEstado\t\tPrioridad\tPC\n"</span><span style="color: #7388d6;">)</span>;
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"----\t-------\t\t---------\t----\n"</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; size; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"%d\t%s\t\t%d\t\t%u\n"</span>, 
               processes<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>.pid, processes<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>.state, processes<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>.priority, processes<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>.pc<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">Funci&#243;n para simular el cambio de estado y actualizar el PC</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">updateProcess</span><span style="color: #707183;">(</span><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Process</span> *<span style="color: #a0522d;">process</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">newState</span>, <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">newPC</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    strcpy<span style="color: #7388d6;">(</span>process-&gt;state, newState<span style="color: #7388d6;">)</span>;
    process-&gt;pc = newPC;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Process</span> <span style="color: #a0522d;">processes</span><span style="color: #7388d6;">[</span>MAX_PROCESSES<span style="color: #7388d6;">]</span>;

    initializeProcesses<span style="color: #7388d6;">(</span>processes, MAX_PROCESSES<span style="color: #7388d6;">)</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">Inicializa los procesos</span>
    displayProcessTable<span style="color: #7388d6;">(</span>processes, MAX_PROCESSES<span style="color: #7388d6;">)</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">Muestra la tabla inicial</span>

    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"\nActualizando estado del proceso 1...\n"</span><span style="color: #7388d6;">)</span>;
    updateProcess<span style="color: #7388d6;">(</span>&amp;processes<span style="color: #909183;">[</span>0<span style="color: #909183;">]</span>, <span style="color: #8b2252;">"Ejecutando"</span>, 100<span style="color: #7388d6;">)</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">Cambia el estado y PC del proceso 1</span>
    displayProcessTable<span style="color: #7388d6;">(</span>processes, MAX_PROCESSES<span style="color: #7388d6;">)</span>;    <span style="color: #b22222;">// </span><span style="color: #b22222;">Muestra la tabla actualizada</span>

    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6775387" class="outline-4">
<h4 id="org6775387">Explicación del Ejemplo</h4>
<div class="outline-text-4" id="text-org6775387">
<ol class="org-ol">
<li><b><b>Definición de Estructura</b></b>: La estructura `Process` representa cada proceso en la tabla. Incluye el <b><b>PID</b></b>, <b><b>estado</b></b>, <b><b>prioridad</b></b>, y <b><b>contador de programa (PC)</b></b>.</li>
<li><b><b>Inicialización de Procesos</b></b>: La función `initializeProcesses` asigna un PID, establece el estado en "Listo", y asigna una prioridad a cada proceso.</li>
<li><b><b>Visualización de la Tabla de Procesos</b></b>: La función `displayProcessTable` imprime la tabla de procesos, mostrando el estado actual de cada proceso.</li>
<li><b><b>Actualización de un Proceso</b></b>: La función `updateProcess` permite cambiar el estado y el contador de programa de un proceso específico, simulando una transición de estado.</li>
</ol>
</div>
</div>

<div id="outline-container-org0422949" class="outline-4">
<h4 id="org0422949">Salida Esperada</h4>
<div class="outline-text-4" id="text-org0422949">
<p>
Al ejecutar el programa, la salida muestra la tabla de procesos inicial y después de actualizar el estado de un proceso.
</p>

<pre class="example">
Tabla de Procesos:
PID   Estado       Prioridad     PC
----  -------      ---------     ----
1     Listo        0             0
2     Listo        1             0
3     Listo        2             0
4     Listo        0             0
5     Listo        1             0
</pre>


<pre class="example">
Actualizando estado del proceso 1...
Tabla de Procesos:
PID   Estado       Prioridad     PC
----  -------      ---------     ----
1     Ejecutando   0             100
2     Listo        1             0
3     Listo        2             0
4     Listo        0             0
5     Listo        1             0
</pre>
</div>
</div>

<div id="outline-container-org25d5767" class="outline-4">
<h4 id="org25d5767">Conclusión</h4>
<div class="outline-text-4" id="text-org25d5767">
<p>
La tabla de procesos es fundamental para el seguimiento y administración
de los procesos en un sistema operativo. Cada proceso tiene su propio
bloque de control con información clave, y el sistema operativo
utiliza esta tabla para planificar, controlar y administrar los
recursos de cada proceso.
</p>
</div>
</div>
</div>






<div id="outline-container-org4c88503" class="outline-3">
<h3 id="org4c88503">Procesos ligeros: Hilos o hebras</h3>
<div class="outline-text-3" id="text-org4c88503">
<p>
Un proceso ligero o hilo es una unidad de ejecución que comparte el
mismo espacio de memoria que otros hilos dentro del mismo proceso. Los
hilos permiten paralelizar tareas en un programa y mejorar la
eficiencia sin crear procesos separados. Los sistemas operativos
modernos proporcionan bibliotecas como POSIX threads (pthreads) para
crear y gestionar hilos.
</p>
</div>

<div id="outline-container-org27418d0" class="outline-4">
<h4 id="org27418d0">Ejemplo en C: Creación de hilos con pthread</h4>
<div class="outline-text-4" id="text-org27418d0">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">tarea</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Hilo en ejecuci&#243;n\n"</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">hilo1</span>, <span style="color: #a0522d;">hilo2</span>;
    pthread_create<span style="color: #7388d6;">(</span>&amp;hilo1, <span style="color: #008b8b;">NULL</span>, tarea, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>; 
    pthread_create<span style="color: #7388d6;">(</span>&amp;hilo2, <span style="color: #008b8b;">NULL</span>, tarea, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;

    pthread_join<span style="color: #7388d6;">(</span>hilo1, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    pthread_join<span style="color: #7388d6;">(</span>hilo2, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Todos los hilos han terminado\n"</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org17c0dff" class="outline-3">
<h3 id="org17c0dff">pthread<sub>create</sub> en C</h3>
<div class="outline-text-3" id="text-org17c0dff">
</div>
<div id="outline-container-org2034196" class="outline-4">
<h4 id="org2034196">Descripción de pthread<sub>create</sub></h4>
<div class="outline-text-4" id="text-org2034196">
<p>
La función `pthread<sub>create</sub>` en C se utiliza para crear y lanzar un
nuevo hilo de ejecución en un programa. Esta función es parte de la
biblioteca <b><b>POSIX Threads (pthreads)</b></b> y permite ejecutar tareas en
paralelo, lo cual es útil para mejorar el rendimiento y realizar
múltiples tareas de forma concurrente.
</p>
</div>
</div>

<div id="outline-container-org00c8f60" class="outline-4">
<h4 id="org00c8f60">Sintaxis de pthread<sub>create</sub></h4>
<div class="outline-text-4" id="text-org00c8f60">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">pthread_create</span><span style="color: #707183;">(</span><span style="color: #228b22;">pthread_t</span> *<span style="color: #a0522d;">thread</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">pthread_attr_t</span> *<span style="color: #a0522d;">attr</span>, <span style="color: #228b22;">void</span> *<span style="color: #7388d6;">(</span>*<span style="color: #0000ff;">start_routine</span><span style="color: #7388d6;">)(</span><span style="color: #228b22;">void</span> *<span style="color: #7388d6;">)</span>, <span style="color: #228b22;">void</span> *<span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org5d6eb9f" class="outline-4">
<h4 id="org5d6eb9f">Parámetros</h4>
<div class="outline-text-4" id="text-org5d6eb9f">
<ul class="org-ul">
<li><b><b>`pthread<sub>t</sub> *thread`</b></b>: Puntero a una variable de tipo `pthread<sub>t</sub>`,
que es el identificador del hilo que se está creando. Al terminar
`pthread<sub>create</sub>`, `*thread` contendrá un identificador único del
hilo creado.</li>
<li><b><b>`const pthread<sub>attr</sub><sub>t</sub> *attr`</b></b>: Atributos específicos del hilo. Si
`attr` es `NULL`, se usarán los atributos predeterminados. Puedes
configurar atributos personalizados con `pthread<sub>attr</sub><sub>init</sub>` y
`pthread<sub>attr</sub><sub>set</sub>`.</li>
<li><b><b>`void *(*start<sub>routine</sub>)(void *)`</b></b>: La función que ejecutará el
hilo. Esta función debe ser de tipo `void*` y recibir un único
argumento de tipo `void*`.</li>
<li><b><b>`void *arg`</b></b>: Argumento que se pasa a la función
`start<sub>routine</sub>`. Permite pasar datos al hilo; si no necesitas pasar
datos, este parámetro puede ser `NULL`.</li>
</ul>
</div>
</div>

<div id="outline-container-org8de324d" class="outline-4">
<h4 id="org8de324d">Valor de Retorno</h4>
<div class="outline-text-4" id="text-org8de324d">
<ul class="org-ul">
<li><b><b>0</b></b>: La función se ejecuta exitosamente y el hilo se crea sin problemas.</li>
<li><b><b>Distinto de 0</b></b>: Devuelve un código de error si la creación del hilo falla.</li>
</ul>
</div>
</div>

<div id="outline-container-org59175ba" class="outline-4">
<h4 id="org59175ba">Ejemplo Práctico de pthread<sub>create</sub></h4>
<div class="outline-text-4" id="text-org59175ba">
<p>
Este ejemplo en C crea un hilo simple que imprime un mensaje
utilizando `pthread<sub>create</sub>`:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdlib.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">tarea</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span> = *<span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>*<span style="color: #7388d6;">)</span>arg; <span style="color: #b22222;">// </span><span style="color: #b22222;">Desreferenciar el puntero para obtener el ID</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Hilo %d en ejecuci&#243;n\n"</span>, id<span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">hilo</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span> = 1;

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Crear el hilo</span>
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>pthread_create<span style="color: #909183;">(</span>&amp;hilo, <span style="color: #008b8b;">NULL</span>, tarea, &amp;id<span style="color: #909183;">)</span> != 0<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        fprintf<span style="color: #909183;">(</span>stderr, <span style="color: #8b2252;">"Error al crear el hilo\n"</span><span style="color: #909183;">)</span>;
        <span style="color: #a020f0;">return</span> 1;
    <span style="color: #7388d6;">}</span>

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Esperar a que el hilo termine</span>
    pthread_join<span style="color: #7388d6;">(</span>hilo, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"El hilo ha terminado\n"</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org23f6851" class="outline-4">
<h4 id="org23f6851">Explicación del Ejemplo</h4>
<div class="outline-text-4" id="text-org23f6851">
<ol class="org-ol">
<li><b><b>Declaración de Hilo y Argumento</b></b>:
<ul class="org-ul">
<li>Se declara `pthread<sub>t</sub> hilo` para almacenar el identificador del hilo.</li>
<li>Se crea una variable `id` con un valor de `1` que se pasa como argumento a la función del hilo.</li>
</ul></li>

<li><b><b>Llamada a `pthread<sub>create</sub>`</b></b>:
<ul class="org-ul">
<li>`pthread<sub>create</sub>` toma como primer argumento la dirección de `hilo` para almacenar el identificador.</li>
<li>`NULL` se usa como segundo argumento para utilizar los atributos predeterminados.</li>
<li>`tarea` es la función que el hilo ejecutará. Debe coincidir con el tipo `void* (<b>)(void</b>)`.</li>
<li>`&amp;id` se pasa como argumento para que `tarea` reciba el valor del identificador del hilo.</li>
</ul></li>

<li><b><b>Ejecuta la Función `tarea` en el Hilo</b></b>:
<ul class="org-ul">
<li>`tarea` toma `arg` y lo desreferencia para obtener el valor de `id`.</li>
<li>La función imprime `"Hilo 1 en ejecución"` y luego termina.</li>
</ul></li>

<li><b><b>Espera a que el Hilo Termine con `pthread<sub>join</sub>`</b></b>:
<ul class="org-ul">
<li><b>pthread<sub>join</sub></b> se usa para esperar a que el hilo termine antes de que el programa principal continúe.</li>
<li>Una vez que el hilo finaliza, el programa principal imprime `"El hilo ha terminado"`.</li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org2804ee0" class="outline-4">
<h4 id="org2804ee0">Consideraciones Importantes</h4>
<div class="outline-text-4" id="text-org2804ee0">
<ul class="org-ul">
<li><b><b>Sincronización</b></b>: <b>pthread<sub>create</sub></b> lanza el hilo inmediatamente,
pero el hilo principal puede necesitar esperar a que el hilo termine
usando <b>pthread<sub>join</sub></b>.</li>
<li><b><b>Paso de Argumentos</b></b>: Si necesitas pasar múltiples datos a la
función del hilo, puedes crear una estructura para empaquetar todos
los datos y pasar un puntero a esa estructura.</li>
<li><b><b>Atributos del Hilo</b></b>: Puedes controlar el tamaño de la pila, la
prioridad, o hacer que el hilo sea "desvinculado" (no esperable)
inicializando y configurando los atributos del hilo con
<b>pthread<sub>attr</sub><sub>init</sub></b> y <b>pthread<sub>attr</sub><sub>set</sub></b>.</li>
</ul>
</div>
</div>

<div id="outline-container-org235635c" class="outline-4">
<h4 id="org235635c">Resumen</h4>
<div class="outline-text-4" id="text-org235635c">
<p>
La función <b>pthread<sub>create</sub></b> permite crear un nuevo hilo y especificar
la tarea que debe ejecutar, lo cual es útil para realizar múltiples
tareas en paralelo dentro del mismo programa, compartiendo memoria y
recursos, y controlando el comportamiento del hilo mediante su
identificador y atributos personalizados.
</p>
</div>
</div>
</div>


<div id="outline-container-org126082f" class="outline-3">
<h3 id="org126082f">cola con prioridad</h3>
<div class="outline-text-3" id="text-org126082f">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdlib.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">time.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">valor</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">prioridad</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> *<span style="color: #a0522d;">siguiente</span>;
<span style="color: #707183;">}</span> <span style="color: #228b22;">nodo</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">numero_aleatorio</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span>rand<span style="color: #909183;">()</span> % 4<span style="color: #7388d6;">)</span> + 1;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">nodo</span>* <span style="color: #0000ff;">genera_proceso</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">static</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">contador</span> = 1;
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">nuevo</span> = <span style="color: #7388d6;">(</span><span style="color: #228b22;">nodo</span>*<span style="color: #7388d6;">)</span>malloc<span style="color: #7388d6;">(</span><span style="color: #a020f0;">sizeof</span><span style="color: #909183;">(</span>nodo<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>nuevo == <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Error al asignar memoria.\n"</span><span style="color: #909183;">)</span>;
        exit<span style="color: #909183;">(</span>1<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    nuevo-&gt;valor = contador++;
    nuevo-&gt;prioridad = numero_aleatorio<span style="color: #7388d6;">()</span>;
    nuevo-&gt;siguiente = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">return</span> nuevo;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">insertar_final</span><span style="color: #707183;">(</span><span style="color: #228b22;">nodo</span>** <span style="color: #a0522d;">cabeza</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">nuevoNodo</span> = genera_proceso<span style="color: #7388d6;">()</span>;

    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>*cabeza == <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        *cabeza = nuevoNodo;
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
        <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">temp</span> = *cabeza;
        <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>temp-&gt;siguiente != <span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            temp = temp-&gt;siguiente;
        <span style="color: #909183;">}</span>
        temp-&gt;siguiente = nuevoNodo;
    <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">imprimir_lista</span><span style="color: #707183;">(</span><span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">cabeza</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">temp</span> = cabeza;
    <span style="color: #a020f0;">while</span> <span style="color: #7388d6;">(</span>temp != <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Proceso %d (Prioridad %d) -&gt; "</span>, temp-&gt;valor, temp-&gt;prioridad<span style="color: #909183;">)</span>;
        temp = temp-&gt;siguiente;
    <span style="color: #7388d6;">}</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"NULL\n"</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">atender_prioridad_mas_alta</span><span style="color: #707183;">(</span><span style="color: #228b22;">nodo</span>** <span style="color: #a0522d;">cabeza</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>*cabeza == <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"No hay procesos para atender.\n"</span><span style="color: #909183;">)</span>;
        <span style="color: #a020f0;">return</span>;
    <span style="color: #7388d6;">}</span>

    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">temp</span> = *cabeza;
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">maxNodo</span> = temp;
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">maxNodoPrevio</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">previo</span> = <span style="color: #008b8b;">NULL</span>;

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Buscar el nodo con la prioridad m&#225;s alta</span>
    <span style="color: #a020f0;">while</span> <span style="color: #7388d6;">(</span>temp != <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>temp-&gt;prioridad &gt; maxNodo-&gt;prioridad<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            maxNodo = temp;
            maxNodoPrevio = previo;
        <span style="color: #909183;">}</span>
        previo = temp;
        temp = temp-&gt;siguiente;
    <span style="color: #7388d6;">}</span>

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Atender el nodo con prioridad m&#225;s alta</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Atendiendo proceso %d con prioridad %d\n"</span>, maxNodo-&gt;valor, maxNodo-&gt;prioridad<span style="color: #7388d6;">)</span>;

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Eliminar el nodo de la lista</span>
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>maxNodoPrevio == <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        *cabeza = maxNodo-&gt;siguiente;  <span style="color: #b22222;">// </span><span style="color: #b22222;">El nodo con mayor prioridad es la cabeza</span>
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
        maxNodoPrevio-&gt;siguiente = maxNodo-&gt;siguiente;
    <span style="color: #7388d6;">}</span>

    free<span style="color: #7388d6;">(</span>maxNodo<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    srand<span style="color: #7388d6;">(</span>time<span style="color: #909183;">(</span><span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">cabeza</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">op</span> = 0;

    <span style="color: #a020f0;">do</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"1. Genera proceso\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"2. Atiende proceso\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"3. Mostrar Lista de Procesos\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"4. Salir\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Seleccione una opci&#243;n: "</span><span style="color: #909183;">)</span>;
        scanf<span style="color: #909183;">(</span><span style="color: #8b2252;">"%d"</span>, &amp;op<span style="color: #909183;">)</span>;

        <span style="color: #a020f0;">switch</span> <span style="color: #909183;">(</span>op<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            <span style="color: #a020f0;">case</span> 1:
                insertar_final<span style="color: #709870;">(</span>&amp;cabeza<span style="color: #709870;">)</span>;
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> 2:
                atender_prioridad_mas_alta<span style="color: #709870;">(</span>&amp;cabeza<span style="color: #709870;">)</span>;
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> 3:
                imprimir_lista<span style="color: #709870;">(</span>cabeza<span style="color: #709870;">)</span>;
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> 4:
                printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"Saliendo...\n"</span><span style="color: #709870;">)</span>;
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">default</span>:
                printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"Opci&#243;n no v&#225;lida\n"</span><span style="color: #709870;">)</span>;
        <span style="color: #909183;">}</span>
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">while</span> <span style="color: #7388d6;">(</span>op != 4<span style="color: #7388d6;">)</span>;

    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>


</pre>
</div>
</div>
</div>




<div id="outline-container-orgc94a636" class="outline-3">
<h3 id="orgc94a636">Concurrencia y Secuenciabilidad</h3>
<div class="outline-text-3" id="text-orgc94a636">
<p>
La concurrencia y secuenciabilidad son conceptos clave en el diseño
y la gestión de sistemas operativos modernos. Permiten que
múltiples procesos y threads se ejecuten de manera simultánea o
alternada en un sistema, maximizando la utilización de recursos y
mejorando la eficiencia general del sistema. 
</p>

<p>
La concurrencia permite ejecutar múltiples tareas
"simultáneamente". Aunque no siempre se ejecutan al mismo tiempo, se
pueden intercalar en un mismo procesador mediante interrupciones y
cambios de contexto. La secuenciabilidad define un orden en estas
tareas concurrentes, permitiendo que se ejecute un bloque de código
mientras otro espera, garantizando la sincronización. En sistemas de
múltiples núcleos, esto puede significar ejecución paralela, mientras
que en sistemas de un solo núcleo implica cambios de contexto rápidos.
</p>

<ul class="org-ul">
<li><b>Objetivo</b>: Permitir que múltiples procesos compartan el CPU y otros
recursos de manera eficiente y sin conflictos.</li>
<li><b>Desafíos</b>: Sincronización de acceso a recursos compartidos, evitar
condiciones de carrera y gestionar la exclusión mutua.</li>
</ul>
</div>


<div id="outline-container-org50cfdcf" class="outline-4">
<h4 id="org50cfdcf">Ejemplo en C: Concurrencia y sincronización de tareas</h4>
<div class="outline-text-4" id="text-org50cfdcf">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">unistd.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">tarea1</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Inicio de tarea 1\n"</span><span style="color: #7388d6;">)</span>;
    sleep<span style="color: #7388d6;">(</span>1<span style="color: #7388d6;">)</span>;
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Fin de tarea 1\n"</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">tarea2</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Inicio de tarea 2\n"</span><span style="color: #7388d6;">)</span>;
    sleep<span style="color: #7388d6;">(</span>1<span style="color: #7388d6;">)</span>;
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Fin de tarea 2\n"</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">hilo1</span>, <span style="color: #a0522d;">hilo2</span>;
    pthread_create<span style="color: #7388d6;">(</span>&amp;hilo1, <span style="color: #008b8b;">NULL</span>, tarea1, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    pthread_create<span style="color: #7388d6;">(</span>&amp;hilo2, <span style="color: #008b8b;">NULL</span>, tarea2, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;

    pthread_join<span style="color: #7388d6;">(</span>hilo1, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    pthread_join<span style="color: #7388d6;">(</span>hilo2, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Ambas tareas han terminado de forma concurrente\n"</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org3cd23ea" class="outline-4">
<h4 id="org3cd23ea">1.1 Exclusión Mutua</h4>
<div class="outline-text-4" id="text-org3cd23ea">
<p>
La exclusión mutua asegura que solo un proceso a la vez pueda acceder
a una sección crítica que manipula recursos compartidos.
</p>
<ul class="org-ul">
<li>Algoritmos comunes:
<ul class="org-ul">
<li>Algoritmo de Dekker</li>
<li>Algoritmo de Peterson</li>
<li>Algoritmo de Lamport’s Bakery</li>
<li>Semáforos y Mutexes</li>
</ul></li>
</ul>
</div>


<ul class="org-ul">
<li><a id="org952a7c6"></a>1. Algoritmo de Dekker<br />
<div class="outline-text-5" id="text-org952a7c6">
<p>
El algoritmo de Dekker es un algoritmo de programación concurrente
para exclusión mutua, que permite a dos procesos o hilos de ejecución
compartir un recurso sin conflictos. Fue uno de los primeros
algoritmos de exclusión mutua inventados, implementado por Edsger
Dijkstra.
</p>

<p>
Si ambos procesos intentan acceder a la sección crítica
simultáneamente, el algoritmo elige un proceso según una variable de
turno. Si el otro proceso está ejecutando en su sección crítica,
deberá esperar su finalización.
</p>
</div>

<ul class="org-ul">
<li><a id="org84f0faa"></a>Condiciones<br />
<div class="outline-text-6" id="text-org84f0faa">
<ul class="org-ul">
<li>No hay prioridad entre procesos.</li>
<li>La capacidad de los equipos es irrelevante.</li>
<li>Si un proceso muere fuera de la región crítica, el algoritmo sigue funcionando.</li>
<li>Un bloqueo mutuo no se considera como solución válida.</li>
</ul>

<p>
Existen cinco versiones del algoritmo Dekker, teniendo ciertos fallos
los primeros cuatro. La versión 5 es la que trabaja más
eficientemente, siendo una combinación de la 1 y la 4.
</p>

<ul class="org-ul">
<li>Versión 1: Alternancia estricta. Garantiza la exclusión mutua, pero
su desventaja es que acopla los procesos fuertemente, esto significa
que los procesos lentos atrasan a los procesos rápidos.</li>
<li>Versión 2: Problema interbloqueo. No existe la alternancia, aunque
ambos procesos caen a un mismo estado y nunca salen de ahí.</li>
<li>Versión 3: Colisión región crítica no garantiza la exclusión
mutua. Este algoritmo no evita que dos procesos puedan acceder al
mismo tiempo a la región crítica.</li>
<li>Versión 4: Postergación indefinida. Aunque los procesos no están en
interbloqueo, un proceso o varios se quedan esperando a que suceda
un evento que tal vez nunca suceda.</li>

<li><b>Variables</b>: `flag[2]` es un arreglo booleano donde `flag[i]` indica
si el proceso `i` desea entrar en la sección crítica.</li>
<li><b>Turno</b>: `turn` indica el turno de los procesos para entrar en la sección crítica.</li>

<li><b>Matemática</b>:
<ul class="org-ul">
<li>Condiciones de entrada a la sección crítica:
<ol class="org-ol">
<li>Si un proceso quiere entrar, establece `flag[i] = true`.</li>
<li>Si el otro proceso también quiere entrar, se usa la variable
`turn` para determinar quién tiene prioridad.</li>
<li>Un proceso entra a la sección crítica si `flag[j] <code>= false` o `turn =</code> i`.</li>
</ol></li>
</ul></li>
</ul>

<p>
Ejemplo de del algoritmo de Dekker en C
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;"> #include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;"> #include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;"> #include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdbool.h</span><span style="color: #707183;">&gt;</span>

 <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">flag</span><span style="color: #707183;">[</span>2<span style="color: #707183;">]</span> = <span style="color: #707183;">{</span><span style="color: #008b8b;">false</span>, <span style="color: #008b8b;">false</span><span style="color: #707183;">}</span>;
 <span style="color: #228b22;">int</span> <span style="color: #a0522d;">turn</span> = 0;

 <span style="color: #228b22;">void</span>* <span style="color: #0000ff;">proceso</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
     <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = *<span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>*<span style="color: #7388d6;">)</span>arg;
     <span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span> = 1 - i;
     flag<span style="color: #7388d6;">[</span>i<span style="color: #7388d6;">]</span> = <span style="color: #008b8b;">true</span>;
     <span style="color: #a020f0;">while</span> <span style="color: #7388d6;">(</span>flag<span style="color: #909183;">[</span>j<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
         <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>turn != i<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
             flag<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span> = <span style="color: #008b8b;">false</span>;
             <span style="color: #a020f0;">while</span> <span style="color: #709870;">(</span>turn != i<span style="color: #709870;">)</span>;
             flag<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span> = <span style="color: #008b8b;">true</span>;
         <span style="color: #909183;">}</span>
     <span style="color: #7388d6;">}</span>
     <span style="color: #b22222;">// </span><span style="color: #b22222;">Secci&#243;n Cr&#237;tica</span>
     printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Proceso %d en secci&#243;n cr&#237;tica\n"</span>, i<span style="color: #7388d6;">)</span>;
     turn = j;
     flag<span style="color: #7388d6;">[</span>i<span style="color: #7388d6;">]</span> = <span style="color: #008b8b;">false</span>;
     
 <span style="color: #707183;">}</span>

 <span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
     <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">t0</span>, <span style="color: #a0522d;">t1</span>;
     <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id0</span> = 0, <span style="color: #a0522d;">id1</span> = 1;
     pthread_create<span style="color: #7388d6;">(</span>&amp;t0, <span style="color: #008b8b;">NULL</span>, proceso, &amp;id0<span style="color: #7388d6;">)</span>;
     pthread_create<span style="color: #7388d6;">(</span>&amp;t1, <span style="color: #008b8b;">NULL</span>, proceso, &amp;id1<span style="color: #7388d6;">)</span>;
     pthread_join<span style="color: #7388d6;">(</span>t0, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
     pthread_join<span style="color: #7388d6;">(</span>t1, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
     <span style="color: #a020f0;">return</span> 0;
 <span style="color: #707183;">}</span>
</pre>
</div>
</div>
</li>


<li><a id="org027f7bc"></a>Productor Consumidor Dekker<br />
<div class="outline-text-6" id="text-org027f7bc">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdlib.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">unistd.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">valor</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> *<span style="color: #a0522d;">siguiente</span>;
<span style="color: #707183;">}</span> <span style="color: #228b22;">nodo</span>;

<span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">cabeza</span> = <span style="color: #008b8b;">NULL</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Cola de procesos</span>

<span style="color: #228b22;">int</span> <span style="color: #a0522d;">turno</span> = 0;           <span style="color: #b22222;">// </span><span style="color: #b22222;">Variable de turno para el algoritmo de Dekker</span>
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">interesado</span><span style="color: #707183;">[</span>2<span style="color: #707183;">]</span> = <span style="color: #707183;">{</span>0, 0<span style="color: #707183;">}</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">Indica si el productor o consumidor est&#225;n interesados</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">insertar_final</span><span style="color: #707183;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">valor</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">nuevo</span> = <span style="color: #7388d6;">(</span><span style="color: #228b22;">nodo</span>*<span style="color: #7388d6;">)</span>malloc<span style="color: #7388d6;">(</span><span style="color: #a020f0;">sizeof</span><span style="color: #909183;">(</span>nodo<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    nuevo-&gt;valor = valor;
    nuevo-&gt;siguiente = cabeza;
    cabeza = nuevo;
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Productor produjo: %d\n"</span>, valor<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">atender_proceso</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>cabeza != <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">temp</span> = cabeza;
        cabeza = cabeza-&gt;siguiente;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Consumidor atendi&#243;: %d\n"</span>, temp-&gt;valor<span style="color: #909183;">)</span>;
        free<span style="color: #909183;">(</span>temp<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"No hay procesos para consumir\n"</span><span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">Funci&#243;n de productor utilizando algoritmo de Dekker</span>
<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">productor</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; 5; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        interesado<span style="color: #909183;">[</span>0<span style="color: #909183;">]</span> = 1;
        <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>interesado<span style="color: #709870;">[</span>1<span style="color: #709870;">]</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            <span style="color: #a020f0;">if</span> <span style="color: #709870;">(</span>turno != 0<span style="color: #709870;">)</span> <span style="color: #709870;">{</span>
                interesado<span style="color: #907373;">[</span>0<span style="color: #907373;">]</span> = 0;
                <span style="color: #a020f0;">while</span> <span style="color: #907373;">(</span>turno != 0<span style="color: #907373;">)</span>;
                interesado<span style="color: #907373;">[</span>0<span style="color: #907373;">]</span> = 1;
            <span style="color: #709870;">}</span>
        <span style="color: #909183;">}</span>
        
        insertar_final<span style="color: #909183;">(</span>i + 1<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Zona cr&#237;tica</span>
        
        turno = 1;
        interesado<span style="color: #909183;">[</span>0<span style="color: #909183;">]</span> = 0;
        sleep<span style="color: #909183;">(</span>1<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Simular producci&#243;n</span>
    <span style="color: #7388d6;">}</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
<span style="color: #707183;">}</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">Funci&#243;n de consumidor utilizando algoritmo de Dekker</span>
<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">consumidor</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; 5; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        interesado<span style="color: #909183;">[</span>1<span style="color: #909183;">]</span> = 1;
        <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>interesado<span style="color: #709870;">[</span>0<span style="color: #709870;">]</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            <span style="color: #a020f0;">if</span> <span style="color: #709870;">(</span>turno != 1<span style="color: #709870;">)</span> <span style="color: #709870;">{</span>
                interesado<span style="color: #907373;">[</span>1<span style="color: #907373;">]</span> = 0;
                <span style="color: #a020f0;">while</span> <span style="color: #907373;">(</span>turno != 1<span style="color: #907373;">)</span>;
                interesado<span style="color: #907373;">[</span>1<span style="color: #907373;">]</span> = 1;
            <span style="color: #709870;">}</span>
        <span style="color: #909183;">}</span>
        
        atender_proceso<span style="color: #909183;">()</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Zona cr&#237;tica</span>
        
        turno = 0;
        interesado<span style="color: #909183;">[</span>1<span style="color: #909183;">]</span> = 0;
        sleep<span style="color: #909183;">(</span>1<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Simular consumo</span>
    <span style="color: #7388d6;">}</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">hilo_productor</span>, <span style="color: #a0522d;">hilo_consumidor</span>;
    
    pthread_create<span style="color: #7388d6;">(</span>&amp;hilo_productor, <span style="color: #008b8b;">NULL</span>, productor, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    pthread_create<span style="color: #7388d6;">(</span>&amp;hilo_consumidor, <span style="color: #008b8b;">NULL</span>, consumidor, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    
    pthread_join<span style="color: #7388d6;">(</span>hilo_productor, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    pthread_join<span style="color: #7388d6;">(</span>hilo_consumidor, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>

</pre>
</div>
</div>
</li>
</ul>
</li>



<li><a id="org87ad90a"></a>2. Algoritmo de Peterson<br />
<div class="outline-text-5" id="text-org87ad90a">
<p>
El algoritmo de Peterson, también conocido como solución de
Peterson,​ es un algoritmo de programación concurrente para exclusión
mutua, que permite a dos o más procesos o hilos de ejecución compartir
un recurso sin conflictos, utilizando sólo memoria compartida para la
comunicación.
</p>

<p>
Gary L. Peterson desarrolló en 1981 el algoritmo básico para dos
procesos, como una simplificación del algoritmo de Dekker. El
algoritmo básico puede generalizarse fácilmente a un número arbitrario
de procesos.3​
</p>

<p>
Este algoritmo es una mejora sobre Dekker, asegurando exclusión mutua
con dos procesos de manera más simple y sin necesidad de turnos
adicionales.
</p>

<ul class="org-ul">
<li><b>Variables</b>: `flag[2]` es un arreglo booleano que indica si el proceso
desea entrar en la sección crítica. `turn` indica el proceso que
tiene prioridad para entrar.</li>
<li><b>Condición de espera</b>: El proceso espera si el otro también quiere
entrar y si es su turno.

<ul class="org-ul">
<li><b>Matemática</b>:
<ul class="org-ul">
<li>Exclusión mutua garantizada porque solo un proceso podrá cumplir
`flag[j] <code>= false || turn =</code> i`.</li>
</ul></li>
</ul></li>
</ul>


<p>
Ejemplo de del algoritmo de Peterson en C
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdbool.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #228b22;">bool</span> <span style="color: #a0522d;">flag</span><span style="color: #707183;">[</span>2<span style="color: #707183;">]</span> = <span style="color: #707183;">{</span><span style="color: #008b8b;">false</span>, <span style="color: #008b8b;">false</span><span style="color: #707183;">}</span>;
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">turn</span>;

<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">proceso</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = *<span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>*<span style="color: #7388d6;">)</span>arg;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span> = 1 - i;
    flag<span style="color: #7388d6;">[</span>i<span style="color: #7388d6;">]</span> = <span style="color: #008b8b;">true</span>;
    turn = j;
    <span style="color: #a020f0;">while</span> <span style="color: #7388d6;">(</span>flag<span style="color: #909183;">[</span>j<span style="color: #909183;">]</span> &amp;&amp; turn == j<span style="color: #7388d6;">)</span>;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Secci&#243;n Cr&#237;tica</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Proceso %d en secci&#243;n cr&#237;tica\n"</span>, i<span style="color: #7388d6;">)</span>;
    flag<span style="color: #7388d6;">[</span>i<span style="color: #7388d6;">]</span> = <span style="color: #008b8b;">false</span>;
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">t0</span>, <span style="color: #a0522d;">t1</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id0</span> = 0, <span style="color: #a0522d;">id1</span> = 1;
    pthread_create<span style="color: #7388d6;">(</span>&amp;t0, <span style="color: #008b8b;">NULL</span>, proceso, &amp;id0<span style="color: #7388d6;">)</span>;
    pthread_create<span style="color: #7388d6;">(</span>&amp;t1, <span style="color: #008b8b;">NULL</span>, proceso, &amp;id1<span style="color: #7388d6;">)</span>;
    pthread_join<span style="color: #7388d6;">(</span>t0, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    pthread_join<span style="color: #7388d6;">(</span>t1, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="org4f23406"></a>Productor Consumidor<br />
<div class="outline-text-6" id="text-org4f23406">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdlib.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">unistd.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MAX_PROCESOS</span> 10

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">valor</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">prioridad</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> *<span style="color: #a0522d;">siguiente</span>;
<span style="color: #707183;">}</span> <span style="color: #228b22;">nodo</span>;

<span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">cabeza</span> = <span style="color: #008b8b;">NULL</span>;

<span style="color: #228b22;">int</span> <span style="color: #a0522d;">turno</span> = 0;
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">interesado</span><span style="color: #707183;">[</span>2<span style="color: #707183;">]</span> = <span style="color: #707183;">{</span>0, 0<span style="color: #707183;">}</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">numero_aleatorio</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span>rand<span style="color: #909183;">()</span> % 4<span style="color: #7388d6;">)</span> + 1;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">nodo</span>* <span style="color: #0000ff;">genera_proceso</span><span style="color: #707183;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">nuevo</span> = <span style="color: #7388d6;">(</span><span style="color: #228b22;">nodo</span>*<span style="color: #7388d6;">)</span>malloc<span style="color: #7388d6;">(</span><span style="color: #a020f0;">sizeof</span><span style="color: #909183;">(</span>nodo<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    nuevo-&gt;valor = id;
    nuevo-&gt;prioridad = numero_aleatorio<span style="color: #7388d6;">()</span>;
    nuevo-&gt;siguiente = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">return</span> nuevo;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">productor</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span> = *<span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>*<span style="color: #7388d6;">)</span>arg;
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; 5; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        interesado<span style="color: #909183;">[</span>0<span style="color: #909183;">]</span> = 1;
        turno = 1;
        <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>interesado<span style="color: #709870;">[</span>1<span style="color: #709870;">]</span> &amp;&amp; turno == 1<span style="color: #909183;">)</span>;

        <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">nuevo</span> = genera_proceso<span style="color: #909183;">(</span>id * 10 + i<span style="color: #909183;">)</span>;
        nuevo-&gt;siguiente = cabeza;
        cabeza = nuevo;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Productor %d gener&#243; proceso %d con prioridad %d\n"</span>, id, nuevo-&gt;valor, nuevo-&gt;prioridad<span style="color: #909183;">)</span>;

        interesado<span style="color: #909183;">[</span>0<span style="color: #909183;">]</span> = 0;
        sleep<span style="color: #909183;">(</span>1<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">consumidor</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span> = *<span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>*<span style="color: #7388d6;">)</span>arg;
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; 5; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        interesado<span style="color: #909183;">[</span>1<span style="color: #909183;">]</span> = 1;
        turno = 0;
        <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>interesado<span style="color: #709870;">[</span>0<span style="color: #709870;">]</span> &amp;&amp; turno == 0<span style="color: #909183;">)</span>;

        <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>cabeza != <span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">temp</span> = cabeza;
            cabeza = cabeza-&gt;siguiente;
            printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"Consumidor %d atendi&#243; proceso %d con prioridad %d\n"</span>, id, temp-&gt;valor, temp-&gt;prioridad<span style="color: #709870;">)</span>;
            free<span style="color: #709870;">(</span>temp<span style="color: #709870;">)</span>;
        <span style="color: #909183;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #909183;">{</span>
            printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"No hay procesos para consumir\n"</span><span style="color: #709870;">)</span>;
        <span style="color: #909183;">}</span>

        interesado<span style="color: #909183;">[</span>1<span style="color: #909183;">]</span> = 0;
        sleep<span style="color: #909183;">(</span>1<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    srand<span style="color: #7388d6;">(</span>time<span style="color: #909183;">(</span><span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">hilo_productor</span>, <span style="color: #a0522d;">hilo_consumidor</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id_productor</span> = 1, <span style="color: #a0522d;">id_consumidor</span> = 2;

    pthread_create<span style="color: #7388d6;">(</span>&amp;hilo_productor, <span style="color: #008b8b;">NULL</span>, productor, &amp;id_productor<span style="color: #7388d6;">)</span>;
    pthread_create<span style="color: #7388d6;">(</span>&amp;hilo_consumidor, <span style="color: #008b8b;">NULL</span>, consumidor, &amp;id_consumidor<span style="color: #7388d6;">)</span>;

    pthread_join<span style="color: #7388d6;">(</span>hilo_productor, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
    pthread_join<span style="color: #7388d6;">(</span>hilo_consumidor, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;

    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>

</pre>
</div>
</div>
</li>
</ul>
</li>

<li><a id="org2abbb6c"></a>3. Algoritmo de Lamport’s Bakery<br />
<div class="outline-text-5" id="text-org2abbb6c">
<p>
El algoritmo de Lamport’s Bakery es una generalización que permite la
exclusión mutua para múltiples procesos, usando una "numeración"
similar a la de una panadería.
</p>

<p>
El algoritmo de la panadería toma su nombre de la costumbre de las
panaderías y tiendas en general, donde las personas al entrar al local
obtienen un número de turno (único) y lo utilizan para que el
dependiente les vaya atendiendo en orden de llegada. El cliente
obtiene su número de turno usando una cinta de papel que ofrece
boletos con números consecutivos.
</p>

<p>
El dependiente sólo puede atender a una persona al mismo tiempo, lo
que concuerda con el uso de un recurso de forma exclusiva: el recurso
es el dependiente y la sección crítica de un cliente es lo que realiza
mientras es atendido.
</p>

<p>
Panaderia 
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">-&gt;</td>
<td class="org-right">2</td>
<td class="org-left">-&gt;</td>
<td class="org-right">3</td>
<td class="org-left">-&gt;</td>
<td class="org-right">4</td>
<td class="org-left">-&gt;</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><b>Variables</b>: `number[i]` representa el turno del proceso `i`. El valor más bajo en `number[i]` representa el turno de prioridad.</li>
<li><b>Matemática</b>:
<ul class="org-ul">
<li>Cada proceso `i` toma un "ticket" (el valor más alto de `number[j] + 1`) antes de entrar en la sección crítica.</li>
<li>El proceso entra en la sección crítica si su "ticket" es el menor o si su índice `i` es menor en caso de empate en el ticket.</li>
</ul></li>
</ul>

<p>
Ejemplo de del algoritmo de Lamport’s Bakery en C
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">       #include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">       #include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">       #include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdbool.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #483d8b;">       #define</span> <span style="color: #a0522d;">NUM_PROCESOS</span> 3
       <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">choosing</span><span style="color: #707183;">[</span>NUM_PROCESOS<span style="color: #707183;">]</span>;
       <span style="color: #228b22;">int</span> <span style="color: #a0522d;">number</span><span style="color: #707183;">[</span>NUM_PROCESOS<span style="color: #707183;">]</span>;

       <span style="color: #228b22;">void</span>* <span style="color: #0000ff;">proceso</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
           <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = *<span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>*<span style="color: #7388d6;">)</span>arg;

           choosing<span style="color: #7388d6;">[</span>i<span style="color: #7388d6;">]</span> = <span style="color: #008b8b;">true</span>;
           number<span style="color: #7388d6;">[</span>i<span style="color: #7388d6;">]</span> = 1;
           <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span> = 0; j &lt; NUM_PROCESOS; j++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
               <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>number<span style="color: #709870;">[</span>j<span style="color: #709870;">]</span> &gt; number<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span><span style="color: #909183;">)</span> number<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span> = number<span style="color: #909183;">[</span>j<span style="color: #909183;">]</span> + 1;
           <span style="color: #7388d6;">}</span>
           choosing<span style="color: #7388d6;">[</span>i<span style="color: #7388d6;">]</span> = <span style="color: #008b8b;">false</span>;

           <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span> = 0; j &lt; NUM_PROCESOS; j++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
               <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>choosing<span style="color: #709870;">[</span>j<span style="color: #709870;">]</span><span style="color: #909183;">)</span>;
               <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>number<span style="color: #709870;">[</span>j<span style="color: #709870;">]</span> != 0 &amp;&amp; <span style="color: #709870;">(</span>number<span style="color: #907373;">[</span>j<span style="color: #907373;">]</span> &lt; number<span style="color: #907373;">[</span>i<span style="color: #907373;">]</span> || <span style="color: #907373;">(</span>number<span style="color: #6276ba;">[</span>j<span style="color: #6276ba;">]</span> == number<span style="color: #6276ba;">[</span>i<span style="color: #6276ba;">]</span> &amp;&amp; j &lt; i<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>;
           <span style="color: #7388d6;">}</span>

           printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Proceso %d en secci&#243;n cr&#237;tica\n"</span>, i<span style="color: #7388d6;">)</span>;

           number<span style="color: #7388d6;">[</span>i<span style="color: #7388d6;">]</span> = 0;
           <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
       <span style="color: #707183;">}</span>

       <span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
           <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">threads</span><span style="color: #7388d6;">[</span>NUM_PROCESOS<span style="color: #7388d6;">]</span>;
           <span style="color: #228b22;">int</span> <span style="color: #a0522d;">ids</span><span style="color: #7388d6;">[</span>NUM_PROCESOS<span style="color: #7388d6;">]</span>;
           <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; NUM_PROCESOS; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
               ids<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span> = i;
               pthread_create<span style="color: #909183;">(</span>&amp;threads<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>, <span style="color: #008b8b;">NULL</span>, proceso, &amp;ids<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span><span style="color: #909183;">)</span>;
           <span style="color: #7388d6;">}</span>
           <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; NUM_PROCESOS; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
               pthread_join<span style="color: #909183;">(</span>threads<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>, <span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span>;
           <span style="color: #7388d6;">}</span>
           <span style="color: #a020f0;">return</span> 0;
       <span style="color: #707183;">}</span>
</pre>
</div>
</div>
</li>

<li><a id="orge2173d0"></a>Productor Consumidor<br />
<div class="outline-text-5" id="text-orge2173d0">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdlib.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">unistd.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MAX_PROCESOS</span> 10

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">valor</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">prioridad</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> *<span style="color: #a0522d;">siguiente</span>;
<span style="color: #707183;">}</span> <span style="color: #228b22;">nodo</span>;

<span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">cabeza</span> = <span style="color: #008b8b;">NULL</span>;

<span style="color: #228b22;">int</span> <span style="color: #a0522d;">turno</span><span style="color: #707183;">[</span>2<span style="color: #707183;">]</span>;
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">eligiendo</span><span style="color: #707183;">[</span>2<span style="color: #707183;">]</span> = <span style="color: #707183;">{</span>0, 0<span style="color: #707183;">}</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">numero_aleatorio</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span>rand<span style="color: #909183;">()</span> % 4<span style="color: #7388d6;">)</span> + 1;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">nodo</span>* <span style="color: #0000ff;">genera_proceso</span><span style="color: #707183;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">nuevo</span> = <span style="color: #7388d6;">(</span><span style="color: #228b22;">nodo</span>*<span style="color: #7388d6;">)</span>malloc<span style="color: #7388d6;">(</span><span style="color: #a020f0;">sizeof</span><span style="color: #909183;">(</span>nodo<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    nuevo-&gt;valor = id;
    nuevo-&gt;prioridad = numero_aleatorio<span style="color: #7388d6;">()</span>;
    nuevo-&gt;siguiente = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">return</span> nuevo;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">max_turno</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> turno<span style="color: #7388d6;">[</span>0<span style="color: #7388d6;">]</span> &gt; turno<span style="color: #7388d6;">[</span>1<span style="color: #7388d6;">]</span> ? turno<span style="color: #7388d6;">[</span>0<span style="color: #7388d6;">]</span> : turno<span style="color: #7388d6;">[</span>1<span style="color: #7388d6;">]</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">productor</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span> = *<span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>*<span style="color: #7388d6;">)</span>arg;
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; 5; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        eligiendo<span style="color: #909183;">[</span>0<span style="color: #909183;">]</span> = 1;
        turno<span style="color: #909183;">[</span>0<span style="color: #909183;">]</span> = max_turno<span style="color: #909183;">()</span> + 1;
        eligiendo<span style="color: #909183;">[</span>0<span style="color: #909183;">]</span> = 0;

        <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>eligiendo<span style="color: #709870;">[</span>1<span style="color: #709870;">]</span><span style="color: #909183;">)</span>;
        <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>turno<span style="color: #709870;">[</span>1<span style="color: #709870;">]</span> != 0 &amp;&amp; <span style="color: #709870;">(</span>turno<span style="color: #907373;">[</span>1<span style="color: #907373;">]</span> &lt; turno<span style="color: #907373;">[</span>0<span style="color: #907373;">]</span> || <span style="color: #907373;">(</span>turno<span style="color: #6276ba;">[</span>1<span style="color: #6276ba;">]</span> == turno<span style="color: #6276ba;">[</span>0<span style="color: #6276ba;">]</span> &amp;&amp; 1 &lt; 0<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>;

        <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">nuevo</span> = genera_proceso<span style="color: #909183;">(</span>id * 10 + i<span style="color: #909183;">)</span>;
        nuevo-&gt;siguiente = cabeza;
        cabeza = nuevo;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Productor %d gener&#243; proceso %d con prioridad %d\n"</span>, id, nuevo-&gt;valor, nuevo-&gt;prioridad<span style="color: #909183;">)</span>;

        turno<span style="color: #909183;">[</span>0<span style="color: #909183;">]</span> = 0;
        sleep<span style="color: #909183;">(</span>1<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">consumidor</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span> = *<span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>*<span style="color: #7388d6;">)</span>arg;
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; 5; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        eligiendo<span style="color: #909183;">[</span>1<span style="color: #909183;">]</span> = 1;
        turno<span style="color: #909183;">[</span>1<span style="color: #909183;">]</span> = max_turno<span style="color: #909183;">()</span> + 1;
        eligiendo<span style="color: #909183;">[</span>1<span style="color: #909183;">]</span> = 0;

        <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>eligiendo<span style="color: #709870;">[</span>0<span style="color: #709870;">]</span><span style="color: #909183;">)</span>;
        <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>turno<span style="color: #709870;">[</span>0<span style="color: #709870;">]</span> != 0 &amp;&amp; <span style="color: #709870;">(</span>turno<span style="color: #907373;">[</span>0<span style="color: #907373;">]</span> &lt; turno<span style="color: #907373;">[</span>1<span style="color: #907373;">]</span> || <span style="color: #907373;">(</span>turno<span style="color: #6276ba;">[</span>0<span style="color: #6276ba;">]</span> == turno<span style="color: #6276ba;">[</span>1<span style="color: #6276ba;">]</span> &amp;&amp; 0 &lt; 1<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>;

        <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>cabeza != <span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">temp</span> = cabeza;
            cabeza = cabeza-&gt;siguiente;
            printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"Consumidor %d atendi&#243; proceso %d con prioridad %d\n"</span>, id, temp-&gt;valor, temp-&gt;prioridad<span style="color: #709870;">)</span>;
            free<span style="color: #709870;">(</span>temp<span style="color: #709870;">)</span>;
        <span style="color: #909183;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #909183;">{</span>
            printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"No hay procesos para consumir\n"</span><span style="color: #709870;">)</span>;
        <span style="color: #909183;">}</span>

        turno<span style="color: #909183;">[</span>1<span style="color: #909183;">]</span> = 0;
        sleep<span style="color: #909183;">(</span>1<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    srand<span style="color: #7388d6;">(</span>time<span style="color: #909183;">(</span><span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">hilo_productor</span>, <span style="color: #a0522d;">hilo_consumidor</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id_productor</span> = 1, <span style="color: #a0522d;">id_consumidor</span> = 2;

    pthread_create<span style="color: #7388d6;">(</span>&amp;hilo_productor, <span style="color: #008b8b;">NULL</span>

</pre>
</div>
</div>
</li>

<li><a id="org6b4a872"></a>4. Semáforos y Mutexes<br />
<div class="outline-text-5" id="text-org6b4a872">
<p>
Los semáforos y mutexes son mecanismos ampliamente utilizados para
manejar la sincronización y exclusión mutua en sistemas operativos
y multihilos.
</p>

<ul class="org-ul">
<li><b>Semáforo</b>: Un contador que controla el acceso de múltiples threads
a un recurso compartido.
<ul class="org-ul">
<li>`wait` (P): Decrementa el contador del semáforo. Si es
negativo, el proceso espera.</li>
<li>`signal` (V): Incrementa el contador, liberando un proceso en espera.</li>
</ul></li>
<li><b>Mutex</b>: Similar a un semáforo binario, asegura que solo un thread
acceda a la sección crítica.</li>
</ul>


<p>
Ejemplo de del algoritmo de Semáforos y Mutexes en C
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">       #include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">       #include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">       #include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">semaphore.h</span><span style="color: #707183;">&gt;</span>

       <span style="color: #228b22;">sem_t</span> <span style="color: #a0522d;">semaforo</span>;

       <span style="color: #228b22;">void</span>* <span style="color: #0000ff;">proceso</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
           sem_wait<span style="color: #7388d6;">(</span>&amp;semaforo<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Entrada en la secci&#243;n cr&#237;tica</span>
           printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Proceso en secci&#243;n cr&#237;tica\n"</span><span style="color: #7388d6;">)</span>;
           sem_post<span style="color: #7388d6;">(</span>&amp;semaforo<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Salida de la secci&#243;n cr&#237;tica</span>
           <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
       <span style="color: #707183;">}</span>

       <span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
           <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">t1</span>, <span style="color: #a0522d;">t2</span>;
           sem_init<span style="color: #7388d6;">(</span>&amp;semaforo, 0, 1<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Inicializa el sem&#225;foro con valor 1</span>
           pthread_create<span style="color: #7388d6;">(</span>&amp;t1, <span style="color: #008b8b;">NULL</span>, proceso, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
           pthread_create<span style="color: #7388d6;">(</span>&amp;t2, <span style="color: #008b8b;">NULL</span>, proceso, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
           pthread_join<span style="color: #7388d6;">(</span>t1, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
           pthread_join<span style="color: #7388d6;">(</span>t2, <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
           sem_destroy<span style="color: #7388d6;">(</span>&amp;semaforo<span style="color: #7388d6;">)</span>;
           <span style="color: #a020f0;">return</span> 0;
       <span style="color: #707183;">}</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdlib.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">time.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">valor</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">prioridad</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> *<span style="color: #a0522d;">siguiente</span>;
<span style="color: #707183;">}</span> <span style="color: #228b22;">nodo</span>;

<span style="color: #228b22;">pthread_mutex_t</span> <span style="color: #a0522d;">mutex</span> = PTHREAD_MUTEX_INITIALIZER; <span style="color: #b22222;">// </span><span style="color: #b22222;">Inicializar el mutex para la sincronizaci&#243;n</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">numero_aleatorio</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span>rand<span style="color: #909183;">()</span> % 4<span style="color: #7388d6;">)</span> + 1;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">nodo</span>* <span style="color: #0000ff;">genera_proceso</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">static</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">contador</span> = 1;
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">nuevo</span> = <span style="color: #7388d6;">(</span><span style="color: #228b22;">nodo</span>*<span style="color: #7388d6;">)</span>malloc<span style="color: #7388d6;">(</span><span style="color: #a020f0;">sizeof</span><span style="color: #909183;">(</span>nodo<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>nuevo == <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Error al asignar memoria.\n"</span><span style="color: #909183;">)</span>;
        exit<span style="color: #909183;">(</span>1<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    nuevo-&gt;valor = contador++;
    nuevo-&gt;prioridad = numero_aleatorio<span style="color: #7388d6;">()</span>;
    nuevo-&gt;siguiente = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">return</span> nuevo;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">insertar_final</span><span style="color: #707183;">(</span><span style="color: #228b22;">nodo</span>** <span style="color: #a0522d;">cabeza</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    pthread_mutex_lock<span style="color: #7388d6;">(</span>&amp;mutex<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Bloquear el acceso a la lista</span>
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">nuevoNodo</span> = genera_proceso<span style="color: #7388d6;">()</span>;

    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>*cabeza == <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        *cabeza = nuevoNodo;
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
        <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">temp</span> = *cabeza;
        <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>temp-&gt;siguiente != <span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            temp = temp-&gt;siguiente;
        <span style="color: #909183;">}</span>
        temp-&gt;siguiente = nuevoNodo;
    <span style="color: #7388d6;">}</span>
    pthread_mutex_unlock<span style="color: #7388d6;">(</span>&amp;mutex<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Liberar el acceso a la lista</span>
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">imprimir_lista</span><span style="color: #707183;">(</span><span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">cabeza</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    pthread_mutex_lock<span style="color: #7388d6;">(</span>&amp;mutex<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Bloquear el acceso a la lista</span>
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">temp</span> = cabeza;
    <span style="color: #a020f0;">while</span> <span style="color: #7388d6;">(</span>temp != <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Proceso %d (Prioridad %d) -&gt; "</span>, temp-&gt;valor, temp-&gt;prioridad<span style="color: #909183;">)</span>;
        temp = temp-&gt;siguiente;
    <span style="color: #7388d6;">}</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"NULL\n"</span><span style="color: #7388d6;">)</span>;
    pthread_mutex_unlock<span style="color: #7388d6;">(</span>&amp;mutex<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Liberar el acceso a la lista</span>
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">atender_prioridad_mas_alta</span><span style="color: #707183;">(</span><span style="color: #228b22;">nodo</span>** <span style="color: #a0522d;">cabeza</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    pthread_mutex_lock<span style="color: #7388d6;">(</span>&amp;mutex<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Bloquear el acceso a la lista</span>
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>*cabeza == <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"No hay procesos para atender.\n"</span><span style="color: #909183;">)</span>;
        pthread_mutex_unlock<span style="color: #909183;">(</span>&amp;mutex<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Liberar el acceso a la lista</span>
        <span style="color: #a020f0;">return</span>;
    <span style="color: #7388d6;">}</span>

    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">temp</span> = *cabeza;
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">maxNodo</span> = temp;
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">maxNodoPrevio</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">previo</span> = <span style="color: #008b8b;">NULL</span>;

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Buscar el nodo con la prioridad m&#225;s alta</span>
    <span style="color: #a020f0;">while</span> <span style="color: #7388d6;">(</span>temp != <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>temp-&gt;prioridad &gt; maxNodo-&gt;prioridad<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            maxNodo = temp;
            maxNodoPrevio = previo;
        <span style="color: #909183;">}</span>
        previo = temp;
        temp = temp-&gt;siguiente;
    <span style="color: #7388d6;">}</span>

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Atender el nodo con prioridad m&#225;s alta</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Atendiendo proceso %d con prioridad %d\n"</span>, maxNodo-&gt;valor, maxNodo-&gt;prioridad<span style="color: #7388d6;">)</span>;

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Eliminar el nodo de la lista</span>
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>maxNodoPrevio == <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        *cabeza = maxNodo-&gt;siguiente;  <span style="color: #b22222;">// </span><span style="color: #b22222;">El nodo con mayor prioridad es la cabeza</span>
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
        maxNodoPrevio-&gt;siguiente = maxNodo-&gt;siguiente;
    <span style="color: #7388d6;">}</span>

    free<span style="color: #7388d6;">(</span>maxNodo<span style="color: #7388d6;">)</span>;
    pthread_mutex_unlock<span style="color: #7388d6;">(</span>&amp;mutex<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Liberar el acceso a la lista</span>
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    srand<span style="color: #7388d6;">(</span>time<span style="color: #909183;">(</span><span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">cabeza</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">op</span> = 0;

    <span style="color: #a020f0;">do</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"1. Genera proceso\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"2. Atiende proceso\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"3. Mostrar Lista de Procesos\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"4. Salir\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Seleccione una opci&#243;n: "</span><span style="color: #909183;">)</span>;
        scanf<span style="color: #909183;">(</span><span style="color: #8b2252;">"%d"</span>, &amp;op<span style="color: #909183;">)</span>;

        <span style="color: #a020f0;">switch</span> <span style="color: #909183;">(</span>op<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            <span style="color: #a020f0;">case</span> 1:
                insertar_final<span style="color: #709870;">(</span>&amp;cabeza<span style="color: #709870;">)</span>;
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> 2:
                atender_prioridad_mas_alta<span style="color: #709870;">(</span>&amp;cabeza<span style="color: #709870;">)</span>;
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> 3:
                imprimir_lista<span style="color: #709870;">(</span>cabeza<span style="color: #709870;">)</span>;
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> 4:
                printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"Saliendo...\n"</span><span style="color: #709870;">)</span>;
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">default</span>:
                printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"Opci&#243;n no v&#225;lida\n"</span><span style="color: #709870;">)</span>;
        <span style="color: #909183;">}</span>
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">while</span> <span style="color: #7388d6;">(</span>op != 4<span style="color: #7388d6;">)</span>;

    pthread_mutex_destroy<span style="color: #7388d6;">(</span>&amp;mutex<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Destruir el mutex al finalizar</span>
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>

</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="org3bd8a05"></a>Productor Consumidos<br />
<div class="outline-text-6" id="text-org3bd8a05">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdlib.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">pthread.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">semaphore.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">unistd.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MAX_PROCESOS</span> 10  <span style="color: #b22222;">// </span><span style="color: #b22222;">Capacidad m&#225;xima de la cola de procesos</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NUM_PRODUCTORES</span> 3
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NUM_CONSUMIDORES</span> 2

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">valor</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">prioridad</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_nodo</span> *<span style="color: #a0522d;">siguiente</span>;
<span style="color: #707183;">}</span> <span style="color: #228b22;">nodo</span>;

<span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">cabeza</span> = <span style="color: #008b8b;">NULL</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Cabeza de la lista de procesos</span>
<span style="color: #228b22;">pthread_mutex_t</span> <span style="color: #a0522d;">mutex</span> = PTHREAD_MUTEX_INITIALIZER; <span style="color: #b22222;">// </span><span style="color: #b22222;">Mutex para sincronizar acceso a la lista</span>
<span style="color: #228b22;">sem_t</span> <span style="color: #a0522d;">espacios</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Sem&#225;foro para los espacios libres en la cola</span>
<span style="color: #228b22;">sem_t</span> <span style="color: #a0522d;">elementos</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Sem&#225;foro para los elementos presentes en la cola</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">numero_aleatorio</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span>rand<span style="color: #909183;">()</span> % 4<span style="color: #7388d6;">)</span> + 1;
<span style="color: #707183;">}</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">Genera un nuevo proceso</span>
<span style="color: #228b22;">nodo</span>* <span style="color: #0000ff;">genera_proceso</span><span style="color: #707183;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">nuevo</span> = <span style="color: #7388d6;">(</span><span style="color: #228b22;">nodo</span>*<span style="color: #7388d6;">)</span>malloc<span style="color: #7388d6;">(</span><span style="color: #a020f0;">sizeof</span><span style="color: #909183;">(</span>nodo<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>nuevo == <span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Error al asignar memoria.\n"</span><span style="color: #909183;">)</span>;
        exit<span style="color: #909183;">(</span>1<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    nuevo-&gt;valor = id;
    nuevo-&gt;prioridad = numero_aleatorio<span style="color: #7388d6;">()</span>;
    nuevo-&gt;siguiente = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">return</span> nuevo;
<span style="color: #707183;">}</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">Funci&#243;n para que el productor agregue procesos a la cola</span>
<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">productor</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span> = *<span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>*<span style="color: #7388d6;">)</span>arg;
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; 5; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> <span style="color: #b22222;">// </span><span style="color: #b22222;">Cada productor produce 5 procesos</span>
        sem_wait<span style="color: #909183;">(</span>&amp;espacios<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Espera a que haya espacio en la cola</span>
        <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">nuevo</span> = genera_proceso<span style="color: #909183;">(</span>id * 10 + i<span style="color: #909183;">)</span>;

        pthread_mutex_lock<span style="color: #909183;">(</span>&amp;mutex<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Bloqueo de acceso a la cola</span>
        nuevo-&gt;siguiente = cabeza;
        cabeza = nuevo;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Productor %d gener&#243; proceso %d con prioridad %d\n"</span>, id, nuevo-&gt;valor, nuevo-&gt;prioridad<span style="color: #909183;">)</span>;
        pthread_mutex_unlock<span style="color: #909183;">(</span>&amp;mutex<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Liberar acceso a la cola</span>

        sem_post<span style="color: #909183;">(</span>&amp;elementos<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Incrementa el contador de elementos</span>
        sleep<span style="color: #909183;">(</span>1<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Simula tiempo de producci&#243;n</span>
    <span style="color: #7388d6;">}</span>
    pthread_exit<span style="color: #7388d6;">(</span><span style="color: #008b8b;">NULL</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">Funci&#243;n para que el consumidor retire y procese el elemento con mayor prioridad</span>
<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">consumidor</span><span style="color: #707183;">(</span><span style="color: #228b22;">void</span>* <span style="color: #a0522d;">arg</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span> = *<span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>*<span style="color: #7388d6;">)</span>arg;
    <span style="color: #a020f0;">while</span> <span style="color: #7388d6;">(</span>1<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        sem_wait<span style="color: #909183;">(</span>&amp;elementos<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Espera a que haya elementos en la cola</span>

        pthread_mutex_lock<span style="color: #909183;">(</span>&amp;mutex<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Bloqueo de acceso a la cola</span>
        <span style="color: #b22222;">// </span><span style="color: #b22222;">Buscar el proceso de mayor prioridad</span>
        <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">temp</span> = cabeza;
        <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">maxNodo</span> = temp;
        <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">maxNodoPrevio</span> = <span style="color: #008b8b;">NULL</span>;
        <span style="color: #228b22;">nodo</span>* <span style="color: #a0522d;">previo</span> = <span style="color: #008b8b;">NULL</span>;

        <span style="color: #a020f0;">while</span> <span style="color: #909183;">(</span>temp != <span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            <span style="color: #a020f0;">if</span> <span style="color: #709870;">(</span>temp-&gt;prioridad &gt; maxNodo-&gt;prioridad<span style="color: #709870;">)</span> <span style="color: #709870;">{</span>
                maxNodo = temp;
                maxNodoPrevio = previo;
            <span style="color: #709870;">}</span>
            previo = temp;
            temp = temp-&gt;siguiente;
        <span style="color: #909183;">}</span>

        <span style="color: #b22222;">// </span><span style="color: #b22222;">Procesar el nodo de mayor prioridad</span>
        <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>maxNodoPrevio == <span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            cabeza = maxNodo-&gt;siguiente;
        <span style="color: #909183;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #909183;">{</span>
            maxNodoPrevio-&gt;siguiente = maxNodo-&gt;siguiente;
        <span style="color: #909183;">}</span>

        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Consumidor %d atendiendo proceso %d con prioridad %d\n"</span>, id, maxNodo-&gt;valor, maxNodo-&gt;prioridad<span style="color: #909183;">)</span>;
        free<span style="color: #909183;">(</span>maxNodo<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Liberar el proceso de la memoria</span>
        pthread_mutex_unlock<span style="color: #909183;">(</span>&amp;mutex<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Liberar acceso a la cola</span>

        sem_post<span style="color: #909183;">(</span>&amp;espacios<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Incrementa el contador de espacios libres</span>
        sleep<span style="color: #909183;">(</span>1<span style="color: #909183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Simula tiempo de procesamiento</span>
    <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    srand<span style="color: #7388d6;">(</span>time<span style="color: #909183;">(</span><span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
    <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">productores</span><span style="color: #7388d6;">[</span>NUM_PRODUCTORES<span style="color: #7388d6;">]</span>;
    <span style="color: #228b22;">pthread_t</span> <span style="color: #a0522d;">consumidores</span><span style="color: #7388d6;">[</span>NUM_CONSUMIDORES<span style="color: #7388d6;">]</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">ids_productores</span><span style="color: #7388d6;">[</span>NUM_PRODUCTORES<span style="color: #7388d6;">]</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">ids_consumidores</span><span style="color: #7388d6;">[</span>NUM_CONSUMIDORES<span style="color: #7388d6;">]</span>;

    sem_init<span style="color: #7388d6;">(</span>&amp;espacios, 0, MAX_PROCESOS<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Inicializa el sem&#225;foro de espacios con el tama&#241;o m&#225;ximo de la cola</span>
    sem_init<span style="color: #7388d6;">(</span>&amp;elementos, 0, 0<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Inicializa el sem&#225;foro de elementos en 0, ya que la cola est&#225; inicialmente vac&#237;a</span>

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Crear hilos productores</span>
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; NUM_PRODUCTORES; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        ids_productores<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span> = i + 1;
        pthread_create<span style="color: #909183;">(</span>&amp;productores<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>, <span style="color: #008b8b;">NULL</span>, productor, &amp;ids_productores<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span><span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Crear hilos consumidores</span>
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; NUM_CONSUMIDORES; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        ids_consumidores<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span> = i + 1;
        pthread_create<span style="color: #909183;">(</span>&amp;consumidores<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>, <span style="color: #008b8b;">NULL</span>, consumidor, &amp;ids_consumidores<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span><span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Esperar a que los productores terminen</span>
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; NUM_PRODUCTORES; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        pthread_join<span style="color: #909183;">(</span>productores<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>, <span style="color: #008b8b;">NULL</span><span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Terminar el programa despu&#233;s de un tiempo</span>
    sleep<span style="color: #7388d6;">(</span>10<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Permitir que los consumidores trabajen un poco antes de finalizar</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Finalizando...\n"</span><span style="color: #7388d6;">)</span>;

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Liberar los recursos</span>
    sem_destroy<span style="color: #7388d6;">(</span>&amp;espacios<span style="color: #7388d6;">)</span>;
    sem_destroy<span style="color: #7388d6;">(</span>&amp;elementos<span style="color: #7388d6;">)</span>;
    pthread_mutex_destroy<span style="color: #7388d6;">(</span>&amp;mutex<span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>

</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>



<div id="outline-container-orgec23cd6" class="outline-4">
<h4 id="orgec23cd6">1.2 Sincronización</h4>
<div class="outline-text-4" id="text-orgec23cd6">
<p>
La sincronización se encarga de coordinar la ejecución de
múltiples procesos o threads para garantizar que operen de manera
ordenada.
</p>
<ul class="org-ul">
<li><b>Semáforos de Dijkstra</b>: Usados para la sincronización y control
de acceso a recursos mediante dos tipos:
<ul class="org-ul">
<li>Semáforo binario (mutex)</li>
<li>Semáforo contador (permite múltiples accesos)</li>
</ul></li>
<li><b>Monitores</b>: Estructuras que permiten que los procesos esperen
hasta que una condición se cumpla.</li>
</ul>
</div>
</div>

<div id="outline-container-org8a7fb58" class="outline-4">
<h4 id="org8a7fb58">1.3 Condiciones de carrera y sincronización</h4>
<div class="outline-text-4" id="text-org8a7fb58">
<p>
Las condiciones de carrera ocurren cuando dos o más procesos acceden a recursos compartidos de manera concurrente y el resultado depende del orden de ejecución. Esto se soluciona con:
</p>
<ul class="org-ul">
<li>Bloqueos de exclusión mutua.</li>
<li>Sincronización a través de semáforos y monitores.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org1ce979d" class="outline-3">
<h3 id="org1ce979d">Secuenciabilidad</h3>
<div class="outline-text-3" id="text-org1ce979d">
<p>
La secuenciabilidad implica gestionar el orden de ejecución de los
procesos o threads en un sistema operativo para asegurar que se
cumplan ciertos requisitos de rendimiento o justicia en el acceso a
recursos. Es fundamental para la planificación de procesos.
</p>

<ul class="org-ul">
<li><b>Objetivo</b>: Asignar CPU a los procesos de forma que se minimicen
tiempos de espera y maximicen el uso del procesador.</li>
</ul>
</div>

<div id="outline-container-org0b9425d" class="outline-4">
<h4 id="org0b9425d">2.1 Algoritmos de Planificación de Procesos</h4>
<div class="outline-text-4" id="text-org0b9425d">
<p>
Los algoritmos de planificación determinan el orden en que se
ejecutan los procesos en la CPU. Los más comunes incluyen:
</p>
<ul class="org-ul">
<li><b>First-Come, First-Served (FCFS)</b>: Los procesos se ejecutan en el orden de llegada.</li>
<li><b>Shortest Job Next (SJN)</b>: El proceso con el tiempo de ejecución
más corto tiene prioridad.</li>
<li><b>Round Robin (RR)</b>: Cada proceso recibe una cantidad fija de
tiempo de CPU, después de la cual pasa al final de la cola.</li>
<li><b>Multilevel Queue Scheduling</b>: Los procesos se agrupan en diferentes colas, cada una con su propio algoritmo de planificación.</li>
<li><b>Priority Scheduling</b>: Los procesos con mayor prioridad se
ejecutan primero, lo cual requiere un manejo cuidadoso para
evitar el "hambruna" de procesos de baja prioridad.</li>
</ul>
</div>
</div>

<div id="outline-container-org6515556" class="outline-4">
<h4 id="org6515556">2.2 Algoritmos de Detección y Prevención de Interbloqueos (Deadlocks)</h4>
<div class="outline-text-4" id="text-org6515556">
<p>
Los interbloqueos ocurren cuando dos o más procesos esperan
indefinidamente por recursos que otros procesos poseen.
</p>
<ul class="org-ul">
<li><b>Condiciones para un Interbloqueo</b>:
<ul class="org-ul">
<li>Exclusión mutua</li>
<li>Retención y espera</li>
<li>No apropiación</li>
<li>Espera circular</li>
</ul></li>

<li><b>Métodos de Prevención</b>:
<ul class="org-ul">
<li><b>Algoritmo del banquero de Dijkstra</b>: Evalúa si la asignación de
recursos puede llevar a un estado seguro o potencialmente
inseguro.</li>
<li><b>Prevención de interbloqueos</b>: Evita que se cumplan las
condiciones para un interbloqueo.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org66040bb" class="outline-4">
<h4 id="org66040bb">2.3 Sincronización y Secuenciabilidad</h4>
<div class="outline-text-4" id="text-org66040bb">
<p>
La sincronización y secuenciabilidad son clave para evitar
conflictos y maximizar el rendimiento. Se utilizan técnicas como:
</p>
<ul class="org-ul">
<li><b>Wait-for Graphs</b>: Muestran dependencias de recursos para detectar
posibles interbloqueos.</li>
<li><b>Petri Nets</b>: Herramientas visuales para analizar sistemas
concurrentes y modelar sincronización y secuenciabilidad.</li>
</ul>
</div>
</div>

<div id="outline-container-org340262c" class="outline-4">
<h4 id="org340262c">3. Conclusión</h4>
<div class="outline-text-4" id="text-org340262c">
<p>
La concurrencia y secuenciabilidad son fundamentales en la gestión de
sistemas operativos modernos. Los algoritmos y métodos descritos
permiten el uso eficiente de recursos, minimizan los tiempos de espera
y evitan conflictos entre procesos. Comprender estos conceptos y sus
implementaciones es esencial para el desarrollo de sistemas operativos
y aplicaciones robustas en entornos concurrentes.
</p>
</div>
</div>
</div>




<div id="outline-container-org85d4b8c" class="outline-3">
<h3 id="org85d4b8c">Niveles, Objetivos y Criterios de Planificación</h3>
<div class="outline-text-3" id="text-org85d4b8c">
<p>
La planificación es el proceso de asignar recursos del sistema a los
procesos, y su objetivo principal es optimizar el rendimiento del
sistema en función de ciertos criterios como el tiempo de respuesta,
la eficiencia y la equidad. Existen varios niveles de planificación,
que determinan cómo se gestionan los procesos en diferentes etapas de
su ciclo de vida.
</p>
</div>

<div id="outline-container-org8800a6e" class="outline-4">
<h4 id="org8800a6e">Niveles de Planificación</h4>
<div class="outline-text-4" id="text-org8800a6e">
<ul class="org-ul">
<li><b><b>Planificación a largo plazo</b></b>: 
<ul class="org-ul">
<li>Este nivel de planificación se encarga de seleccionar qué procesos deben entrar en el sistema para su ejecución.</li>
<li>Controla el grado de multiprogramación del sistema, es decir, el número de procesos que se ejecutan en un momento dado.</li>
<li>Decisiones de planificación a largo plazo suelen tomarse con menor frecuencia y se realizan en sistemas de tipo batch o procesamiento por lotes.</li>
</ul></li>
<li><b><b>Planificación a medio plazo</b></b>:
<ul class="org-ul">
<li>Se encarga de manejar los procesos que están en espera o en suspensión, decidiendo cuáles de ellos pasarán a estado "listo" para su ejecución.</li>
<li>Es importante en sistemas donde existe una limitación de recursos, ya que ayuda a equilibrar la carga liberando o activando procesos según el estado de los recursos del sistema.</li>
<li>Este nivel ayuda a optimizar la eficiencia en sistemas donde algunos procesos deben esperar debido a la disponibilidad limitada de memoria o CPU.</li>
</ul></li>
<li><b><b>Planificación a corto plazo</b></b>:
<ul class="org-ul">
<li>Este nivel se encarga de seleccionar cuál de los procesos en estado "listo" va a ser ejecutado por la CPU.</li>
<li>Es el nivel más frecuente de planificación y su objetivo es minimizar el tiempo de inactividad de la CPU, cambiando de proceso rápidamente.</li>
<li>Los algoritmos de planificación a corto plazo incluyen Round Robin, SJF y planificación por prioridad.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orge0c1309" class="outline-4">
<h4 id="orge0c1309">Objetivos de la Planificación</h4>
<div class="outline-text-4" id="text-orge0c1309">
<ul class="org-ul">
<li><b><b>Optimización del tiempo de respuesta</b></b>: Especialmente importante en sistemas interactivos, donde los usuarios esperan respuestas rápidas.</li>
<li><b><b>Maximización del rendimiento</b></b>: Ejecutar la mayor cantidad de procesos posible en un tiempo determinado.</li>
<li><b><b>Equidad</b></b>: Asegurar que todos los procesos tengan una oportunidad justa de utilizar la CPU y evitar la inanición o starvation de procesos.</li>
<li><b><b>Minimización del tiempo de espera</b></b>: Reducir el tiempo que un proceso permanece en la cola esperando ser ejecutado.</li>
</ul>
</div>
</div>

<div id="outline-container-orga12c0dd" class="outline-4">
<h4 id="orga12c0dd">Criterios de Planificación</h4>
<div class="outline-text-4" id="text-orga12c0dd">
<ul class="org-ul">
<li><b><b>Equidad</b></b>: El sistema debe asignar recursos de manera equitativa, evitando el bloqueo de procesos de baja prioridad.</li>
<li><b><b>Eficiencia</b></b>: Aumentar la utilización de la CPU al máximo, minimizando el tiempo de inactividad.</li>
<li><b><b>Tiempo de respuesta</b></b>: Reducir el tiempo que tarda el sistema en responder a una solicitud del usuario.</li>
<li><b><b>Tiempo de espera</b></b>: Minimizar el tiempo que un proceso pasa esperando en la cola de "listos".</li>
<li><b><b>Tiempo de retorno</b></b>: Minimizar el tiempo total que un proceso tarda desde que se envía hasta que finaliza.</li>
</ul>
</div>
</div>

<div id="outline-container-org46d0fb1" class="outline-4">
<h4 id="org46d0fb1">Ejemplo en C: Implementación Simple de Planificación Round Robin</h4>
<div class="outline-text-4" id="text-org46d0fb1">
<p>
El siguiente código en C es una implementación simple de un esquema de
planificación Round Robin. En este ejemplo, se simulan tres procesos
que se ejecutan en un bucle y cada proceso tiene un intervalo de
tiempo fijo para su ejecución.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">unistd.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">proceso</span><span style="color: #707183;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">id</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Proceso %d en ejecuci&#243;n\n"</span>, id<span style="color: #7388d6;">)</span>;
    sleep<span style="color: #7388d6;">(</span>1<span style="color: #7388d6;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Tiempo simulado de ejecuci&#243;n del proceso</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Proceso %d terminado\n"</span>, id<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">n_procesos</span> = 3;
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n_procesos; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        proceso<span style="color: #909183;">(</span>i<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfeb9f94" class="outline-3">
<h3 id="orgfeb9f94">Técnicas de Administración del Planificador</h3>
<div class="outline-text-3" id="text-orgfeb9f94">
<p>
El planificador utiliza varias técnicas para mejorar la gestión de
procesos y optimizar el rendimiento del sistema. Algunas de las
técnicas principales incluyen:
</p>

<ul class="org-ul">
<li><b><b>Round Robin</b></b>: 
<ul class="org-ul">
<li>En este algoritmo, cada proceso recibe una franja de tiempo
fija (quantum) para su ejecución.</li>
<li>Si un proceso no se completa durante su quantum, se coloca al
final de la cola de procesos listos, y la CPU se asigna al
siguiente proceso.</li>
<li>Es una técnica equitativa y adecuada para sistemas de tiempo
compartido, aunque el tamaño del quantum debe elegirse con
cuidado.</li>
</ul></li>

<li><b><b>Prioridad</b></b>:
<ul class="org-ul">
<li>Este algoritmo asigna a cada proceso una prioridad, y los
procesos con mayor prioridad tienen preferencia para ser
ejecutados.</li>
<li>La prioridad puede ser estática (fija) o dinámica (cambia
durante la ejecución).</li>
<li>A veces se emplea un mecanismo de "envejecimiento" para
aumentar la prioridad de procesos que llevan mucho tiempo
esperando, evitando que queden bloqueados.</li>
</ul></li>

<li><b><b>Planificación en tiempo real</b></b>:
<ul class="org-ul">
<li>Utilizada en sistemas donde las tareas deben completarse dentro
de plazos específicos, como sistemas de control industrial o de
aviación.</li>
<li><b><b>Tiempo real estricto</b></b>: Las tareas deben completarse en un
momento específico; una falla en el tiempo se considera una
falla total.</li>
<li><b><b>Tiempo real flexible</b></b>: Es tolerante a algunos retrasos, pero
prioriza la finalización de tareas dentro de límites
razonables.</li>
</ul></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org32366b7" class="outline-2">
<h2 id="org32366b7">Administración de la memoria</h2>
<div class="outline-text-2" id="text-org32366b7">
</div>
<div id="outline-container-org4e4fecd" class="outline-3">
<h3 id="org4e4fecd">Política y filosofía de la administración de memoria</h3>
<div class="outline-text-3" id="text-org4e4fecd">
<p>
La administración de memoria en los sistemas operativos sigue
principios fundamentales que guían su diseño y operación. Entre las
políticas más comunes están:
</p>

<ul class="org-ul">
<li><b><b>Asignación dinámica vs. estática</b></b>: ¿Se asigna memoria en tiempo de
ejecución o durante la compilación?</li>
<li><b><b>Swapping</b></b>: ¿Cómo se manejan los procesos que no caben en la memoria física?</li>
<li><b><b>Fragmentación</b></b>: Estrategias para minimizar la fragmentación interna y externa.</li>
<li><b><b>Prioridades</b></b>: Asignación de memoria basada en la prioridad de los procesos.</li>
</ul>

<p>
<b><b>Ejemplo</b></b>: La política de "First Fit" en la asignación de memoria
busca el primer bloque libre suficiente, promoviendo la velocidad pero
pudiendo causar fragmentación.
</p>
</div>



<div id="outline-container-org096bb91" class="outline-4">
<h4 id="org096bb91">Ejemplos de administración de memoria</h4>
<div class="outline-text-4" id="text-org096bb91">
</div>
<ul class="org-ul">
<li><a id="org99203d8"></a>Asignación dinámica vs. estática<br />
<div class="outline-text-5" id="text-org99203d8">
<p>
La asignación dinámica y estática se refiere al momento en el que se
reserva la memoria para un programa.
</p>

<ul class="org-ul">
<li><b><b>Asignación estática</b></b>: La memoria se asigna durante la compilación y no cambia en tiempo de ejecución.
<ul class="org-ul">
<li><p>
Ejemplo en C:
</p>
<div class="org-src-container">
<pre class="src src-c">    <span style="color: #228b22;">nodo</span> <span style="color: #a0522d;">arr</span><span style="color: #707183;">[</span>1000000<span style="color: #707183;">]</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Asignaci&#243;n est&#225;tica</span>
</pre>
</div></li>
<li>Limitación: El tamaño es fijo y debe conocerse antes de la ejecución.</li>
</ul></li>
</ul>
<p>
0x21[1°°°°°°°°°°°°°°°°°°°°°°][  ]
</p>
<ul class="org-ul">
<li><b><b>Asignación dinámica</b></b>: La memoria se asigna durante la ejecución según las necesidades del programa.
<ul class="org-ul">
<li><p>
Ejemplo en C:
</p>
<div class="org-src-container">
<pre class="src src-c">    <span style="color: #228b22;">int</span> *<span style="color: #a0522d;">arr</span> = malloc<span style="color: #707183;">(</span>10 * <span style="color: #a020f0;">sizeof</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
               <span style="color: #228b22;">realloc</span>    <span style="color: #b22222;">// </span><span style="color: #b22222;">Asignaci&#243;n din&#225;mica</span>
    <span style="color: #0000ff;">free</span><span style="color: #707183;">(</span>arr<span style="color: #707183;">)</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">Liberaci&#243;n de memoria</span>
<span style="color: #228b22;">ox34</span><span style="color: #707183;">[</span>&#176;&#176;&#176;&#176;&#176;&#176;<span style="color: #707183;">][</span>                    <span style="color: #707183;">]</span>

</pre>
</div></li>
<li>Ventaja: Permite manejar estructuras cuyo tamaño no es conocido previamente.</li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgd75a3cb" class="outline-4">
<h4 id="orgd75a3cb">Swapping</h4>
<div class="outline-text-4" id="text-orgd75a3cb">
<p>
El swapping consiste en mover procesos completos entre la memoria
principal y el disco para liberar espacio.
</p>

<ul class="org-ul">
<li><b><b>Ejemplo de uso</b></b>:
<ul class="org-ul">
<li>Un proceso que no cabe en memoria se guarda temporalmente en el disco.</li>
<li>Cuando se necesita, se carga nuevamente en memoria.</li>
</ul></li>

<li><p>
<b><b>Diagrama</b></b>:
</p>
<pre class="example" id="org798ec40">
  Memoria principal:
  [Proceso A] [Proceso B] [Libre]
  
  Disco:
  [Proceso C]

  Acción: Mover "Proceso C" del disco a la memoria y "Proceso B" al disco.
</pre></li>

<li><b><b>Ventajas</b></b>: Mejora la utilización de memoria.</li>
<li><b><b>Desventajas</b></b>: Incrementa el tiempo de acceso debido a operaciones en disco.</li>
</ul>
</div>
</div>

<div id="outline-container-orgb85b50d" class="outline-4">
<h4 id="orgb85b50d">Fragmentación</h4>
<div class="outline-text-4" id="text-orgb85b50d">
<p>
La fragmentación ocurre cuando la memoria se utiliza de manera
ineficiente, dejando pequeños bloques no utilizables.
</p>

<ul class="org-ul">
<li><b><b>Fragmentación interna</b></b>:
<ul class="org-ul">
<li>Bloques asignados son más grandes de lo necesario.</li>
<li>Estrategia: Usar bloques más pequeños o ajustar el tamaño según la solicitud.</li>
<li><p>
Ejemplo:
</p>
<pre class="example" id="org3014e03">
    Solicitud: 10 KB
    Bloque asignado: 16 KB (6 KB desperdiciados)
</pre></li>
</ul></li>

<li><b><b>Fragmentación externa</b></b>:
<ul class="org-ul">
<li>Bloques libres no son contiguos, impidiendo asignaciones grandes.</li>
<li>Estrategia: Compactación de memoria o paginación.</li>
<li><p>
Ejemplo:
</p>
<pre class="example" id="orgbce5385">
    [Libre 10 KB] [Usado 50 KB] [Libre 15 KB]
    Solicitud: 20 KB -&gt; Fallo (No hay bloques contiguos de 20 KB)
</pre></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgb8eefee" class="outline-4">
<h4 id="orgb8eefee">Prioridades</h4>
<div class="outline-text-4" id="text-orgb8eefee">
<p>
La asignación basada en prioridades otorga más recursos a procesos críticos.
</p>

<ul class="org-ul">
<li><b><b>Ejemplo</b></b>:
<ul class="org-ul">
<li>Procesos con alta prioridad reciben memoria inmediatamente.</li>
<li>Procesos de baja prioridad esperan.</li>
</ul></li>

<li><p>
<b><b>Simulación de asignación</b></b>:
</p>
<pre class="example" id="org799743a">
  Prioridad: 
  - Proceso A: Alta (Se asigna memoria primero)
  - Proceso B: Media
  - Proceso C: Baja (Espera)

  Resultado:
  Memoria asignada a A y B, C espera por liberación.
</pre></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgc7c86a2" class="outline-3">
<h3 id="orgc7c86a2">Memoria real</h3>
<div class="outline-text-3" id="text-orgc7c86a2">
<p>
La memoria real es la memoria física disponible en un sistema, como la
RAM. Los sistemas operativos deben administrarla eficientemente para
optimizar el rendimiento.
</p>

<ul class="org-ul">
<li><b><b>Características</b></b>:
<ul class="org-ul">
<li>Recursos limitados.</li>
<li>Acceso más rápido que la memoria secundaria.</li>
</ul></li>
<li><b><b>Administración</b></b>:
<ul class="org-ul">
<li>Dividir en bloques o particiones.</li>
<li>Mantener tablas de uso de memoria.</li>
</ul></li>
</ul>

<p>
<b><b>Ejemplo</b></b>: En sistemas monoprogramados, un único proceso utiliza toda
la memoria disponible, mientras que en sistemas multiprogramados se
asignan particiones a múltiples procesos.
</p>
</div>
</div>

<div id="outline-container-org816e73e" class="outline-3">
<h3 id="org816e73e">Organización de memoria virtual</h3>
<div class="outline-text-3" id="text-org816e73e">
<p>
La memoria virtual permite a los programas utilizar más memoria de la
que físicamente está disponible en el sistema. Esto se logra mediante
la abstracción de la memoria secundaria como parte del espacio de
direcciones.
</p>

<ul class="org-ul">
<li><b><b>Esquema de organización</b></b>:
<ul class="org-ul">
<li><b><b>Paginación</b></b>: Divide la memoria en bloques de tamaño fijo (páginas).</li>
<li><b><b>Segmentación</b></b>: Divide la memoria en bloques de tamaño variable
según las necesidades lógicas.</li>
<li><b><b>Paginación con segmentación</b></b>: Combinación de ambas técnicas.</li>
</ul></li>
</ul>

<p>
<b><b>Ventajas</b></b>:
</p>
<ul class="org-ul">
<li>Multiprogramación eficiente.</li>
<li>Aislamiento de procesos.</li>
<li>Manejo simplificado de espacios de memoria grandes.</li>
</ul>

<p>
<b><b>Ejemplo</b></b>:
Un proceso puede acceder a una dirección lógica, que el sistema operativo traduce a una dirección física mediante una tabla de páginas.
</p>
</div>
</div>

<div id="outline-container-org0a40e34" class="outline-3">
<h3 id="org0a40e34">Administración de memoria virtual</h3>
<div class="outline-text-3" id="text-org0a40e34">
<p>
Administración de Memoria Virtual
La memoria virtual es un mecanismo que permite a los sistemas
operativos manejar más memoria de la que físicamente está
disponible. Este concepto se basa en la abstracción de la memoria,
permitiendo que los programas trabajen como si tuvieran acceso a un
espacio de memoria continuo y de gran tamaño, independientemente de
las limitaciones físicas.
</p>

<p>
La administración de memoria virtual es responsable de asignar,
liberar y mantener las estructuras necesarias para garantizar la
operación eficiente de este sistema.
</p>
</div>

<div id="outline-container-org4f3be3a" class="outline-4">
<h4 id="org4f3be3a">Estrategias de Asignación</h4>
<div class="outline-text-4" id="text-org4f3be3a">
</div>
<ul class="org-ul">
<li><a id="org1d522fc"></a>Algoritmos de reemplazo de páginas<br />
<div class="outline-text-5" id="text-org1d522fc">
<p>
Cuando un proceso solicita una página que no está en memoria y no hay espacio disponible, el sistema debe decidir qué página existente se reemplazará. Los algoritmos más comunes son:
</p>

<ul class="org-ul">
<li><b><b>LRU (Least Recently Used)</b></b>:
<ul class="org-ul">
<li>Reemplaza la página que no ha sido utilizada durante más tiempo.</li>
<li>Simula el comportamiento real de los procesos, priorizando páginas recientes.</li>
<li><b><b>Ventaja</b></b>: Buen desempeño en cargas de trabajo típicas.</li>
<li><b><b>Desventaja</b></b>: Costoso en términos de tiempo y espacio, ya que requiere seguimiento continuo del uso de las páginas.</li>
</ul></li>

<li><b><b>FIFO (First In, First Out)</b></b>:
<ul class="org-ul">
<li>Reemplaza la página más antigua en la memoria (la que ingresó primero).</li>
<li><b><b>Ventaja</b></b>: Simplicidad en la implementación.</li>
<li><b><b>Desventaja</b></b>: Puede generar resultados ineficientes, como el problema de <b><b>Belady</b></b> (más fallos de página al aumentar el tamaño de la memoria).</li>
</ul></li>

<li><b><b>Optimal</b></b>:
<ul class="org-ul">
<li>Reemplaza la página que no se necesitará por más tiempo en el futuro.</li>
<li><b><b>Ventaja</b></b>: Ofrece el menor número posible de fallos de página.</li>
<li><b><b>Desventaja</b></b>: Impracticable en sistemas reales, ya que requiere conocer el acceso futuro.</li>
</ul></li>
</ul>
</div>
</li>

<li><a id="org21821ac"></a>Políticas de carga<br />
<div class="outline-text-5" id="text-org21821ac">
<p>
Las políticas de carga determinan cuándo se traen las páginas desde el almacenamiento secundario a la memoria principal.
</p>

<ul class="org-ul">
<li><b><b>Demand Paging</b></b>:
<ul class="org-ul">
<li>Solo se cargan las páginas cuando se necesitan, minimizando el uso inicial de memoria.</li>
<li><b><b>Ventaja</b></b>: Conserva memoria y reduce el tiempo de carga inicial.</li>
<li><b><b>Desventaja</b></b>: Puede aumentar los fallos de página en el inicio de un proceso.</li>
</ul></li>

<li><b><b>Prefetching</b></b>:
<ul class="org-ul">
<li>Se cargan páginas anticipadamente basándose en patrones de acceso previstos.</li>
<li><b><b>Ventaja</b></b>: Reduce los fallos de página si las predicciones son correctas.</li>
<li><b><b>Desventaja</b></b>: Puede desperdiciar recursos si las predicciones son incorrectas.</li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>

<div id="outline-container-org338d1d2" class="outline-4">
<h4 id="org338d1d2">Componentes Principales</h4>
<div class="outline-text-4" id="text-org338d1d2">
</div>
<ul class="org-ul">
<li><a id="org21673d1"></a>Tabla de Páginas<br />
<div class="outline-text-5" id="text-org21673d1">
<p>
La tabla de páginas es una estructura de datos clave que relaciona las direcciones lógicas (utilizadas por los programas) con las direcciones físicas (en la memoria).
</p>

<ul class="org-ul">
<li><b><b>Estructura</b></b>:
<ul class="org-ul">
<li>Contiene entradas que mapean páginas lógicas a marcos de memoria física.</li>
<li>Cada entrada incluye información sobre si la página está presente en la memoria, bits de protección y un bit de referencia.</li>
</ul></li>

<li><b><b>Desempeño</b></b>:
<ul class="org-ul">
<li>Las tablas de páginas grandes pueden consumir mucha memoria.</li>
<li>Para optimizar, se usan tablas multinivel o tablas invertidas.</li>
</ul></li>
</ul>
</div>
</li>

<li><a id="org1df4b4b"></a>TLB (Translation Lookaside Buffer)<br />
<div class="outline-text-5" id="text-org1df4b4b">
<p>
El <b><b>TLB</b></b> es una memoria caché especializada que acelera la traducción de direcciones lógicas a físicas.
</p>

<ul class="org-ul">
<li><b><b>Funcionamiento</b></b>:
<ul class="org-ul">
<li>Almacena un subconjunto de las entradas de la tabla de páginas.</li>
<li>Si una dirección lógica se encuentra en el TLB (<b><b>hit</b></b>), la traducción es rápida.</li>
<li>Si no está en el TLB (<b><b>miss</b></b>), se accede a la tabla de páginas, lo que toma más tiempo.</li>
</ul></li>

<li><b><b>Ventajas</b></b>:
<ul class="org-ul">
<li>Reduce significativamente la latencia de acceso a memoria.</li>
<li>Mejora el rendimiento en sistemas con altas tasas de traducción de direcciones.</li>
</ul></li>
</ul>
</div>
</li>

<li><a id="orgd3e2757"></a>Swap<br />
<div class="outline-text-5" id="text-orgd3e2757">
<p>
El <b><b>swap</b></b> es un mecanismo que permite liberar espacio en la memoria física moviendo páginas no activas al disco.
</p>

<ul class="org-ul">
<li><b><b>Funcionamiento</b></b>:
<ul class="org-ul">
<li>Cuando no hay suficiente memoria física, las páginas no utilizadas recientemente se escriben en una porción del disco conocida como <b><b>archivo de intercambio</b></b>.</li>
<li>Si se requiere nuevamente, la página se trae de vuelta a la memoria, reemplazando otra si es necesario.</li>
</ul></li>

<li><b><b>Ventajas</b></b>:
<ul class="org-ul">
<li>Permite ejecutar más procesos simultáneamente.</li>
<li>Amplía efectivamente el tamaño de la memoria física.</li>
</ul></li>

<li><b><b>Desventajas</b></b>:
<ul class="org-ul">
<li>El acceso a disco es mucho más lento que el acceso a memoria física.</li>
<li>El uso excesivo de swap puede causar degradación del rendimiento (<b><b>thrashing</b></b>).</li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>

<div id="outline-container-org79538d8" class="outline-4">
<h4 id="org79538d8">Ejemplo: Proceso de Fallo de Página</h4>
<div class="outline-text-4" id="text-org79538d8">
</div>
<ul class="org-ul">
<li><a id="org24df509"></a>Escenario<br />
<div class="outline-text-5" id="text-org24df509">
<p>
Un proceso solicita una página que no está en memoria. Esto genera un <b><b>page fault</b></b>.
</p>

<ol class="org-ol">
<li><b><b>Detección del fallo</b></b>:
<ul class="org-ul">
<li>El sistema operativo detecta que la página solicitada no está en memoria.</li>
</ul></li>

<li><b><b>Selección de la página a reemplazar</b></b>:
<ul class="org-ul">
<li>Se utiliza un algoritmo, como LRU, para elegir una página existente en memoria para reemplazar.</li>
</ul></li>

<li><b><b>Swap in y swap out</b></b>:
<ul class="org-ul">
<li>Si la página seleccionada se modificó, se escribe en disco (<b><b>swap out</b></b>).</li>
<li>La página solicitada se lee del disco y se coloca en memoria (<b><b>swap in</b></b>).</li>
</ul></li>

<li><b><b>Actualización de estructuras</b></b>:
<ul class="org-ul">
<li>La tabla de páginas y, si es aplicable, el TLB se actualizan con la nueva información.</li>
</ul></li>
</ol>
</div>
</li>

<li><a id="orgebcf2ee"></a>Código Representativo (C Pseudocódigo)<br />
<div class="outline-text-5" id="text-orgebcf2ee">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">if</span> <span style="color: #707183;">(</span>page_fault<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    page_to_replace = select_page_LRU<span style="color: #7388d6;">()</span>;
    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>page_to_replace.modified<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        write_to_disk<span style="color: #909183;">(</span>page_to_replace<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
    new_page = read_from_disk<span style="color: #7388d6;">(</span>requested_page<span style="color: #7388d6;">)</span>;
    update_page_table<span style="color: #7388d6;">(</span>new_page, memory_frame<span style="color: #7388d6;">)</span>;
    update_TLB<span style="color: #7388d6;">(</span>new_page, memory_frame<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>



<div id="outline-container-orgb0ce7a4" class="outline-3">
<h3 id="orgb0ce7a4">Ejercicios</h3>
<div class="outline-text-3" id="text-orgb0ce7a4">
<ol class="org-ol">
<li>Simulación de particiones fijas:</li>

<li>Escribe un programa que simule un sistema de administración de
memoria con particiones fijas.</li>
<li>Debe permitir al usuario definir el tamaño total de la memoria y las
particiones.</li>
<li>Simula la asignación y liberación de procesos a las particiones,
mostrando cómo se utiliza la memoria.</li>
</ol>
</div>

<div id="outline-container-org1e9aa75" class="outline-4">
<h4 id="org1e9aa75">Respuestas</h4>
<div class="outline-text-4" id="text-org1e9aa75">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdlib.h</span><span style="color: #707183;">&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">string.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MAX_PARTICIONES</span> 100
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MAX_PROCESOS</span> 100

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">tamano</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id_de_proceso</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">-1 si el proceso no es asignado</span>
<span style="color: #707183;">}</span> <span style="color: #228b22;">Particion</span>;

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">imprime_memoria</span><span style="color: #707183;">(</span><span style="color: #228b22;">Particion</span> <span style="color: #a0522d;">Particions</span><span style="color: #7388d6;">[]</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">numero_de_particiones</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"\nEstado de la memoria:\n"</span><span style="color: #7388d6;">)</span>;
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; numero_de_particiones; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>Particions<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>.id_de_proceso == -1<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"Partici&#243;n %d: %d KB (Libre)\n"</span>, i + 1, Particions<span style="color: #907373;">[</span>i<span style="color: #907373;">]</span>.tamano<span style="color: #709870;">)</span>;
        <span style="color: #909183;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #909183;">{</span>
            printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"Partici&#243;n %d: %d KB (Proceso %d)\n"</span>, i + 1, Particions<span style="color: #907373;">[</span>i<span style="color: #907373;">]</span>.tamano, Particions<span style="color: #907373;">[</span>i<span style="color: #907373;">]</span>.id_de_proceso<span style="color: #709870;">)</span>;
        <span style="color: #909183;">}</span>
    <span style="color: #7388d6;">}</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"\n"</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">memoria_total</span>, <span style="color: #a0522d;">numero_de_particiones</span>;
    <span style="color: #228b22;">Particion</span> <span style="color: #a0522d;">Particions</span><span style="color: #7388d6;">[</span>MAX_PARTICIONES<span style="color: #7388d6;">]</span>;

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Solicitar tama&#241;o total de la memoria</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Ingrese el tama&#241;o total de la memoria (KB): "</span><span style="color: #7388d6;">)</span>;
    scanf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"%d"</span>, &amp;memoria_total<span style="color: #7388d6;">)</span>;

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Solicitar n&#250;mero de particiones</span>
    printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"Ingrese el n&#250;mero de particiones: "</span><span style="color: #7388d6;">)</span>;
    scanf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"%d"</span>, &amp;numero_de_particiones<span style="color: #7388d6;">)</span>;

    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>numero_de_particiones &gt; MAX_PARTICIONES<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"N&#250;mero m&#225;ximo de particiones excedido (%d).\n"</span>, MAX_PARTICIONES<span style="color: #909183;">)</span>;
        <span style="color: #a020f0;">return</span> 1;
    <span style="color: #7388d6;">}</span>

    <span style="color: #b22222;">// </span><span style="color: #b22222;">Solicitar tama&#241;os de las particiones</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">tamano_total_particion</span> = 0;
    <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; numero_de_particiones; i++<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Ingrese el tama&#241;o de la partici&#243;n %d (KB): "</span>, i + 1<span style="color: #909183;">)</span>;
        scanf<span style="color: #909183;">(</span><span style="color: #8b2252;">"%d"</span>, &amp;Particions<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>.tamano<span style="color: #909183;">)</span>;
        Particions<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span>.id_de_proceso = -1; <span style="color: #b22222;">// </span><span style="color: #b22222;">Inicialmente, todas est&#225;n libres</span>
        tamano_total_particion += Particions<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span>.tamano;
    <span style="color: #7388d6;">}</span>

    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>tamano_total_particion &gt; memoria_total<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Error: El tama&#241;o total de las particiones excede el tama&#241;o de la memoria.\n"</span><span style="color: #909183;">)</span>;
        <span style="color: #a020f0;">return</span> 1;
    <span style="color: #7388d6;">}</span>

    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">op</span>;
    <span style="color: #a020f0;">do</span> <span style="color: #7388d6;">{</span>
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"\n--- Men&#250; ---\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"1. Asignar proceso\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"2. Liberar proceso\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"3. Mostrar estado de la memoria\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"4. Salir\n"</span><span style="color: #909183;">)</span>;
        printf<span style="color: #909183;">(</span><span style="color: #8b2252;">"Seleccione una opci&#243;n: "</span><span style="color: #909183;">)</span>;
        scanf<span style="color: #909183;">(</span><span style="color: #8b2252;">"%d"</span>, &amp;op<span style="color: #909183;">)</span>;

        <span style="color: #a020f0;">switch</span> <span style="color: #909183;">(</span>op<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            <span style="color: #a020f0;">case</span> 1: <span style="color: #709870;">{</span>
                <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id_de_proceso</span>, <span style="color: #a0522d;">tam_proceso</span>;
                printf<span style="color: #907373;">(</span><span style="color: #8b2252;">"Ingrese el ID del proceso: "</span><span style="color: #907373;">)</span>;
                scanf<span style="color: #907373;">(</span><span style="color: #8b2252;">"%d"</span>, &amp;id_de_proceso<span style="color: #907373;">)</span>;
                printf<span style="color: #907373;">(</span><span style="color: #8b2252;">"Ingrese el tama&#241;o del proceso (KB): "</span><span style="color: #907373;">)</span>;
                scanf<span style="color: #907373;">(</span><span style="color: #8b2252;">"%d"</span>, &amp;tam_proceso<span style="color: #907373;">)</span>;

                <span style="color: #228b22;">int</span> <span style="color: #a0522d;">asignado</span> = 0;
                <span style="color: #a020f0;">for</span> <span style="color: #907373;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; numero_de_particiones; i++<span style="color: #907373;">)</span> <span style="color: #907373;">{</span>
                    <span style="color: #a020f0;">if</span> <span style="color: #6276ba;">(</span>Particions<span style="color: #858580;">[</span>i<span style="color: #858580;">]</span>.id_de_proceso == -1 &amp;&amp; Particions<span style="color: #858580;">[</span>i<span style="color: #858580;">]</span>.tamano &gt;= tam_proceso<span style="color: #6276ba;">)</span> <span style="color: #6276ba;">{</span>
                        Particions<span style="color: #858580;">[</span>i<span style="color: #858580;">]</span>.id_de_proceso = id_de_proceso;
                        asignado = 1;
                        printf<span style="color: #858580;">(</span><span style="color: #8b2252;">"Proceso %d asignado a la partici&#243;n %d.\n"</span>, id_de_proceso, i + 1<span style="color: #858580;">)</span>;
                        <span style="color: #a020f0;">break</span>;
                    <span style="color: #6276ba;">}</span>
                <span style="color: #907373;">}</span>
                <span style="color: #a020f0;">if</span> <span style="color: #907373;">(</span>!asignado<span style="color: #907373;">)</span> <span style="color: #907373;">{</span>
                    printf<span style="color: #6276ba;">(</span><span style="color: #8b2252;">"No se encontr&#243; una partici&#243;n disponible para el proceso %d.\n"</span>, id_de_proceso<span style="color: #6276ba;">)</span>;
                <span style="color: #907373;">}</span>
                <span style="color: #a020f0;">break</span>;
            <span style="color: #709870;">}</span>
            <span style="color: #a020f0;">case</span> 2: <span style="color: #709870;">{</span>
                <span style="color: #228b22;">int</span> <span style="color: #a0522d;">id_de_proceso</span>;
                printf<span style="color: #907373;">(</span><span style="color: #8b2252;">"Ingrese el ID del proceso a liberar: "</span><span style="color: #907373;">)</span>;
                scanf<span style="color: #907373;">(</span><span style="color: #8b2252;">"%d"</span>, &amp;id_de_proceso<span style="color: #907373;">)</span>;

                <span style="color: #228b22;">int</span> <span style="color: #a0522d;">libre</span> = 0;
                <span style="color: #a020f0;">for</span> <span style="color: #907373;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; numero_de_particiones; i++<span style="color: #907373;">)</span> <span style="color: #907373;">{</span>
                    <span style="color: #a020f0;">if</span> <span style="color: #6276ba;">(</span>Particions<span style="color: #858580;">[</span>i<span style="color: #858580;">]</span>.id_de_proceso == id_de_proceso<span style="color: #6276ba;">)</span> <span style="color: #6276ba;">{</span>
                        Particions<span style="color: #858580;">[</span>i<span style="color: #858580;">]</span>.id_de_proceso = -1;
                        libre = 1;
                        printf<span style="color: #858580;">(</span><span style="color: #8b2252;">"Proceso %d liberado de la partici&#243;n %d.\n"</span>, id_de_proceso, i + 1<span style="color: #858580;">)</span>;
                        <span style="color: #a020f0;">break</span>;
                    <span style="color: #6276ba;">}</span>
                <span style="color: #907373;">}</span>
                <span style="color: #a020f0;">if</span> <span style="color: #907373;">(</span>!libre<span style="color: #907373;">)</span> <span style="color: #907373;">{</span>
                    printf<span style="color: #6276ba;">(</span><span style="color: #8b2252;">"No se encontr&#243; el proceso %d en ninguna partici&#243;n.\n"</span>, id_de_proceso<span style="color: #6276ba;">)</span>;
                <span style="color: #907373;">}</span>
                <span style="color: #a020f0;">break</span>;
            <span style="color: #709870;">}</span>
            <span style="color: #a020f0;">case</span> 3:
                imprime_memoria<span style="color: #709870;">(</span>Particions, numero_de_particiones<span style="color: #709870;">)</span>;
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> 4:
                printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"Saliendo del programa.\n"</span><span style="color: #709870;">)</span>;
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">default</span>:
                printf<span style="color: #709870;">(</span><span style="color: #8b2252;">"Opci&#243;n no v&#225;lida.\n"</span><span style="color: #709870;">)</span>;
        <span style="color: #909183;">}</span>
    <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">while</span> <span style="color: #7388d6;">(</span>op != 4<span style="color: #7388d6;">)</span>;

    <span style="color: #a020f0;">return</span> 0;
<span style="color: #707183;">}</span>

</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org573b4f0" class="outline-2">
<h2 id="org573b4f0">Problema de los Filósofos</h2>
<div class="outline-text-2" id="text-org573b4f0">
<p>
Cinco filósofos se sientan alrededor de una mesa y pasan su vida
cenando y pensando. Cada filósofo tiene un plato de fideos y un
tenedor a la izquierda de su plato. Para comer los fideos son
necesarios dos tenedores y cada filósofo sólo puede tomar los que
están a su izquierda y derecha. Si cualquier filósofo toma un tenedor
y el otro está ocupado, se quedará esperando, con el tenedor en la
mano, hasta que pueda tomar el otro tenedor, para luego empezar a
comer.
Si dos filósofos adyacentes intentan tomar el mismo tenedor a una vez,
se produce una condición de carrera: ambos compiten por tomar el mismo
tenedor, y uno de ellos se queda sin comer.
Si todos los filósofos toman el tenedor que está a su derecha al mismo
tiempo, entonces todos se quedarán esperando eternamente, porque
alguien debe liberar el tenedor que les falta. Nadie lo hará porque
todos se encuentran en la misma situación (esperando que alguno deje
sus tenedores). Entonces los filósofos se morirán de hambre. 
El problema consiste en encontrar un algoritmo que permita que los
filósofos nunca se mueran de hambre.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Autor: likcos</p>
<p class="date">Created: 2024-11-22 vie 14:55</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
